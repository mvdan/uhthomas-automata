// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1beta1

package v1beta1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// PostgresClusterSpec defines the desired state of PostgresCluster
#PostgresClusterSpec: {
	// +optional
	metadata?: null | #Metadata @go(Metadata,*Metadata)

	// Specifies a data source for bootstrapping the PostgreSQL cluster.
	// +optional
	dataSource?: null | #DataSource @go(DataSource,*DataSource)

	// PostgreSQL backup configuration
	// +kubebuilder:validation:Required
	backups: #Backups @go(Backups)

	// The secret containing the Certificates and Keys to encrypt PostgreSQL
	// traffic will need to contain the server TLS certificate, TLS key and the
	// Certificate Authority certificate with the data keys set to tls.crt,
	// tls.key and ca.crt, respectively. It will then be mounted as a volume
	// projection to the '/pgconf/tls' directory. For more information on
	// Kubernetes secret projections, please see
	// https://k8s.io/docs/concepts/configuration/secret/#projection-of-secret-keys-to-specific-paths
	// NOTE: If CustomTLSSecret is provided, CustomReplicationClientTLSSecret
	// MUST be provided and the ca.crt provided must be the same.
	// +optional
	customTLSSecret?: null | corev1.#SecretProjection @go(CustomTLSSecret,*corev1.SecretProjection)

	// The secret containing the replication client certificates and keys for
	// secure connections to the PostgreSQL server. It will need to contain the
	// client TLS certificate, TLS key and the Certificate Authority certificate
	// with the data keys set to tls.crt, tls.key and ca.crt, respectively.
	// NOTE: If CustomReplicationClientTLSSecret is provided, CustomTLSSecret
	// MUST be provided and the ca.crt provided must be the same.
	// +optional
	customReplicationTLSSecret?: null | corev1.#SecretProjection @go(CustomReplicationClientTLSSecret,*corev1.SecretProjection)

	// DatabaseInitSQL defines a ConfigMap containing custom SQL that will
	// be run after the cluster is initialized. This ConfigMap must be in the same
	// namespace as the cluster.
	// +optional
	databaseInitSQL?: null | #DatabaseInitSQL @go(DatabaseInitSQL,*DatabaseInitSQL)

	// Whether or not the PostgreSQL cluster should use the defined default
	// scheduling constraints. If the field is unset or false, the default
	// scheduling constraints will be used in addition to any custom constraints
	// provided.
	// +optional
	disableDefaultPodScheduling?: null | bool @go(DisableDefaultPodScheduling,*bool)

	// The image name to use for PostgreSQL containers. When omitted, the value
	// comes from an operator environment variable. For standard PostgreSQL images,
	// the format is RELATED_IMAGE_POSTGRES_{postgresVersion},
	// e.g. RELATED_IMAGE_POSTGRES_13. For PostGIS enabled PostgreSQL images,
	// the format is RELATED_IMAGE_POSTGRES_{postgresVersion}_GIS_{postGISVersion},
	// e.g. RELATED_IMAGE_POSTGRES_13_GIS_3.1.
	// +optional
	// +operator-sdk:csv:customresourcedefinitions:type=spec,order=1
	image?: string @go(Image)

	// ImagePullPolicy is used to determine when Kubernetes will attempt to
	// pull (download) container images.
	// More info: https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
	// +kubebuilder:validation:Enum={Always,Never,IfNotPresent}
	// +optional
	imagePullPolicy?: corev1.#PullPolicy @go(ImagePullPolicy)

	// The image pull secrets used to pull from a private registry
	// Changing this value causes all running pods to restart.
	// https://k8s.io/docs/tasks/configure-pod-container/pull-image-private-registry/
	// +optional
	imagePullSecrets?: [...corev1.#LocalObjectReference] @go(ImagePullSecrets,[]corev1.LocalObjectReference)

	// Specifies one or more sets of PostgreSQL pods that replicate data for
	// this cluster.
	// +listType=map
	// +listMapKey=name
	// +kubebuilder:validation:MinItems=1
	// +operator-sdk:csv:customresourcedefinitions:type=spec,order=2
	instances: [...#PostgresInstanceSetSpec] @go(InstanceSets,[]PostgresInstanceSetSpec)

	// Whether or not the PostgreSQL cluster is being deployed to an OpenShift
	// environment. If the field is unset, the operator will automatically
	// detect the environment.
	// +optional
	openshift?: null | bool @go(OpenShift,*bool)

	// +optional
	patroni?: null | #PatroniSpec @go(Patroni,*PatroniSpec)

	// Suspends the rollout and reconciliation of changes made to the
	// PostgresCluster spec.
	// +optional
	paused?: null | bool @go(Paused,*bool)

	// The port on which PostgreSQL should listen.
	// +optional
	// +kubebuilder:default=5432
	// +kubebuilder:validation:Minimum=1024
	port?: null | int32 @go(Port,*int32)

	// The major version of PostgreSQL installed in the PostgreSQL image
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Minimum=10
	// +kubebuilder:validation:Maximum=15
	// +operator-sdk:csv:customresourcedefinitions:type=spec,order=1
	postgresVersion: int @go(PostgresVersion)

	// The PostGIS extension version installed in the PostgreSQL image.
	// When image is not set, indicates a PostGIS enabled image will be used.
	// +optional
	postGISVersion?: string @go(PostGISVersion)

	// The specification of a proxy that connects to PostgreSQL.
	// +optional
	proxy?: null | #PostgresProxySpec @go(Proxy,*PostgresProxySpec)

	// The specification of a user interface that connects to PostgreSQL.
	// +optional
	userInterface?: null | #UserInterfaceSpec @go(UserInterface,*UserInterfaceSpec)

	// The specification of monitoring tools that connect to PostgreSQL
	// +optional
	monitoring?: null | #MonitoringSpec @go(Monitoring,*MonitoringSpec)

	// Specification of the service that exposes the PostgreSQL primary instance.
	// +optional
	service?: null | #ServiceSpec @go(Service,*ServiceSpec)

	// Whether or not the PostgreSQL cluster should be stopped.
	// When this is true, workloads are scaled to zero and CronJobs
	// are suspended.
	// Other resources, such as Services and Volumes, remain in place.
	// +optional
	shutdown?: null | bool @go(Shutdown,*bool)

	// Run this cluster as a read-only copy of an existing cluster or archive.
	// +optional
	standby?: null | #PostgresStandbySpec @go(Standby,*PostgresStandbySpec)

	// A list of group IDs applied to the process of a container. These can be
	// useful when accessing shared file systems with constrained permissions.
	// More info: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
	// +optional
	supplementalGroups?: [...int64] @go(SupplementalGroups,[]int64)

	// Users to create inside PostgreSQL and the databases they should access.
	// The default creates one user that can access one database matching the
	// PostgresCluster name. An empty list creates no users. Removing a user
	// from this list does NOT drop the user nor revoke their access.
	// +listType=map
	// +listMapKey=name
	// +optional
	users?: [...#PostgresUserSpec] @go(Users,[]PostgresUserSpec)
	config?: #PostgresAdditionalConfig @go(Config)
}

// DataSource defines data sources for a new PostgresCluster.
#DataSource: {
	// Defines a pgBackRest cloud-based data source that can be used to pre-populate the
	// the PostgreSQL data directory for a new PostgreSQL cluster using a pgBackRest restore.
	// The PGBackRest field is incompatible with the PostgresCluster field: only one
	// data source can be used for pre-populating a new PostgreSQL cluster
	// +optional
	pgbackrest?: null | #PGBackRestDataSource @go(PGBackRest,*PGBackRestDataSource)

	// Defines a pgBackRest data source that can be used to pre-populate the PostgreSQL data
	// directory for a new PostgreSQL cluster using a pgBackRest restore.
	// The PGBackRest field is incompatible with the PostgresCluster field: only one
	// data source can be used for pre-populating a new PostgreSQL cluster
	// +optional
	postgresCluster?: null | #PostgresClusterDataSource @go(PostgresCluster,*PostgresClusterDataSource)

	// Defines any existing volumes to reuse for this PostgresCluster.
	// +optional
	volumes?: null | #DataSourceVolumes @go(Volumes,*DataSourceVolumes)
}

// DataSourceVolumes defines any existing volumes to reuse for this PostgresCluster.
#DataSourceVolumes: {
	// Defines the existing pgData volume and directory to use in the current
	// PostgresCluster.
	// +optional
	pgDataVolume?: null | #DataSourceVolume @go(PGDataVolume,*DataSourceVolume)

	// Defines the existing pg_wal volume and directory to use in the current
	// PostgresCluster. Note that a defined pg_wal volume MUST be accompanied by
	// a pgData volume.
	// +optional
	pgWALVolume?: null | #DataSourceVolume @go(PGWALVolume,*DataSourceVolume)

	// Defines the existing pgBackRest repo volume and directory to use in the
	// current PostgresCluster.
	// +optional
	pgBackRestVolume?: null | #DataSourceVolume @go(PGBackRestVolume,*DataSourceVolume)
}

// DataSourceVolume defines the PVC name and data diretory path for an existing cluster volume.
#DataSourceVolume: {
	// The existing PVC name.
	pvcName: string @go(PVCName)

	// The existing directory. When not set, a move Job is not created for the
	// associated volume.
	// +optional
	directory?: string @go(Directory)
}

// DatabaseInitSQL defines a ConfigMap containing custom SQL that will
// be run after the cluster is initialized. This ConfigMap must be in the same
// namespace as the cluster.
#DatabaseInitSQL: {
	// Name is the name of a ConfigMap
	// +required
	name: string @go(Name)

	// Key is the ConfigMap data key that points to a SQL string
	// +required
	key: string @go(Key)
}

// PostgresClusterDataSource defines a data source for bootstrapping PostgreSQL clusters using a
// an existing PostgresCluster.
#PostgresClusterDataSource: {
	// The name of an existing PostgresCluster to use as the data source for the new PostgresCluster.
	// Defaults to the name of the PostgresCluster being created if not provided.
	// +optional
	clusterName?: string @go(ClusterName)

	// The namespace of the cluster specified as the data source using the clusterName field.
	// Defaults to the namespace of the PostgresCluster being created if not provided.
	// +optional
	clusterNamespace?: string @go(ClusterNamespace)

	// The name of the pgBackRest repo within the source PostgresCluster that contains the backups
	// that should be utilized to perform a pgBackRest restore when initializing the data source
	// for the new PostgresCluster.
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=^repo[1-4]
	repoName: string @go(RepoName)

	// Command line options to include when running the pgBackRest restore command.
	// https://pgbackrest.org/command.html#command-restore
	// +optional
	options?: [...string] @go(Options,[]string)

	// Resource requirements for the pgBackRest restore Job.
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// Scheduling constraints of the pgBackRest restore Job.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
	// +optional
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// Priority class name for the pgBackRest restore Job pod. Changing this
	// value causes PostgreSQL to restart.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
	// +optional
	priorityClassName?: null | string @go(PriorityClassName,*string)

	// Tolerations of the pgBackRest restore Job.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)
}

// Backups defines a PostgreSQL archive configuration
#Backups: {
	// pgBackRest archive configuration
	// +kubebuilder:validation:Required
	pgbackrest: #PGBackRestArchive @go(PGBackRest)
}

// PostgresClusterStatus defines the observed state of PostgresCluster
#PostgresClusterStatus: {
	// Identifies the databases that have been installed into PostgreSQL.
	databaseRevision?: string @go(DatabaseRevision)

	// Current state of PostgreSQL instances.
	// +listType=map
	// +listMapKey=name
	// +optional
	instances?: [...#PostgresInstanceSetStatus] @go(InstanceSets,[]PostgresInstanceSetStatus)

	// +optional
	patroni?: #PatroniStatus @go(Patroni)

	// Status information for pgBackRest
	// +optional
	pgbackrest?: null | #PGBackRestStatus @go(PGBackRest,*PGBackRestStatus)

	// Stores the current PostgreSQL major version following a successful
	// major PostgreSQL upgrade.
	// +optional
	postgresVersion: int @go(PostgresVersion)

	// Current state of the PostgreSQL proxy.
	// +optional
	proxy?: #PostgresProxyStatus @go(Proxy)

	// The instance that should be started first when bootstrapping and/or starting a
	// PostgresCluster.
	// +optional
	startupInstance?: string @go(StartupInstance)

	// The instance set associated with the startupInstance
	// +optional
	startupInstanceSet?: string @go(StartupInstanceSet)

	// Current state of the PostgreSQL user interface.
	// +optional
	userInterface?: null | #PostgresUserInterfaceStatus @go(UserInterface,*PostgresUserInterfaceStatus)

	// Identifies the users that have been installed into PostgreSQL.
	usersRevision?: string @go(UsersRevision)

	// Current state of PostgreSQL cluster monitoring tool configuration
	// +optional
	monitoring?: #MonitoringStatus @go(Monitoring)

	// DatabaseInitSQL state of custom database initialization in the cluster
	// +optional
	databaseInitSQL?: null | string @go(DatabaseInitSQL,*string)

	// observedGeneration represents the .metadata.generation on which the status was based.
	// +optional
	// +kubebuilder:validation:Minimum=0
	observedGeneration?: int64 @go(ObservedGeneration)

	// conditions represent the observations of postgrescluster's current state.
	// Known .status.conditions.type are: "PersistentVolumeResizing",
	// "Progressing", "ProxyAvailable"
	// +optional
	// +listType=map
	// +listMapKey=type
	// +operator-sdk:csv:customresourcedefinitions:type=status,xDescriptors={"urn:alm:descriptor:io.kubernetes.conditions"}
	conditions?: [...metav1.#Condition] @go(Conditions,[]metav1.Condition)
}

#PersistentVolumeResizing:   "PersistentVolumeResizing"
#PostgresClusterProgressing: "Progressing"
#ProxyAvailable:             "ProxyAvailable"

#PostgresInstanceSetSpec: {
	// +optional
	metadata?: null | #Metadata @go(Metadata,*Metadata)

	// Name that associates this set of PostgreSQL pods. This field is optional
	// when only one instance set is defined. Each instance set in a cluster
	// must have a unique name. The combined length of this and the cluster name
	// must be 46 characters or less.
	// +optional
	// +kubebuilder:default=""
	// +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?)?$`
	name: string @go(Name)

	// Scheduling constraints of a PostgreSQL pod. Changing this value causes
	// PostgreSQL to restart.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
	// +optional
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// Custom sidecars for PostgreSQL instance pods. Changing this value causes
	// PostgreSQL to restart.
	// +optional
	containers?: [...corev1.#Container] @go(Containers,[]corev1.Container)

	// Defines a PersistentVolumeClaim for PostgreSQL data.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
	// +kubebuilder:validation:Required
	dataVolumeClaimSpec: corev1.#PersistentVolumeClaimSpec @go(DataVolumeClaimSpec)

	// Priority class name for the PostgreSQL pod. Changing this value causes
	// PostgreSQL to restart.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
	// +optional
	priorityClassName?: null | string @go(PriorityClassName,*string)

	// Number of desired PostgreSQL pods.
	// +optional
	// +kubebuilder:default=1
	// +kubebuilder:validation:Minimum=1
	replicas?: null | int32 @go(Replicas,*int32)

	// Minimum number of pods that should be available at a time.
	// Defaults to one when the replicas field is greater than one.
	// +optional
	minAvailable?: null | intstr.#IntOrString @go(MinAvailable,*intstr.IntOrString)

	// Compute resources of a PostgreSQL container.
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// Configuration for instance sidecar containers
	// +optional
	sidecars?: null | #InstanceSidecars @go(Sidecars,*InstanceSidecars)

	// Tolerations of a PostgreSQL pod. Changing this value causes PostgreSQL to restart.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// Topology spread constraints of a PostgreSQL pod. Changing this value causes
	// PostgreSQL to restart.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
	// +optional
	topologySpreadConstraints?: [...corev1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]corev1.TopologySpreadConstraint)

	// Defines a separate PersistentVolumeClaim for PostgreSQL's write-ahead log.
	// More info: https://www.postgresql.org/docs/current/wal.html
	// +optional
	walVolumeClaimSpec?: null | corev1.#PersistentVolumeClaimSpec @go(WALVolumeClaimSpec,*corev1.PersistentVolumeClaimSpec)

	// The list of tablespaces volumes to mount for this postgrescluster
	// This field requires enabling TablespaceVolumes feature gate
	// +listType=map
	// +listMapKey=name
	// +optional
	tablespaceVolumes?: [...#TablespaceVolume] @go(TablespaceVolumes,[]TablespaceVolume)
}

#TablespaceVolume: {
	// The name for the tablespace, used as the path name for the volume.
	// Must be unique in the instance set since they become the directory names.
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern=`^[a-z][a-z0-9]*$`
	// +kubebuilder:validation:Type=string
	name: string @go(Name)

	// Defines a PersistentVolumeClaim for a tablespace.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
	// +kubebuilder:validation:Required
	dataVolumeClaimSpec: corev1.#PersistentVolumeClaimSpec @go(DataVolumeClaimSpec)
}

// InstanceSidecars defines the configuration for instance sidecar containers
#InstanceSidecars: {
	// Defines the configuration for the replica cert copy sidecar container
	// +optional
	replicaCertCopy?: null | #Sidecar @go(ReplicaCertCopy,*Sidecar)
}

#PostgresInstanceSetStatus: {
	name: string @go(Name)

	// Total number of ready pods.
	// +optional
	readyReplicas?: int32 @go(ReadyReplicas)

	// Total number of pods.
	// +optional
	replicas?: int32 @go(Replicas)

	// Total number of pods that have the desired specification.
	// +optional
	updatedReplicas?: int32 @go(UpdatedReplicas)
}

// PostgresProxySpec is a union of the supported PostgreSQL proxies.
#PostgresProxySpec: {
	// Defines a PgBouncer proxy and connection pooler.
	pgBouncer?: null | #PGBouncerPodSpec @go(PGBouncer,*PGBouncerPodSpec)
}

#PostgresProxyStatus: {
	pgBouncer?: #PGBouncerPodStatus @go(PGBouncer)
}

// PostgresStandbySpec defines if/how the cluster should be a hot standby.
#PostgresStandbySpec: {
	// Whether or not the PostgreSQL cluster should be read-only. When this is
	// true, WAL files are applied from a pgBackRest repository or another
	// PostgreSQL server.
	// +optional
	// +kubebuilder:default=true
	enabled: bool @go(Enabled)

	// The name of the pgBackRest repository to follow for WAL files.
	// +optional
	// +kubebuilder:validation:Pattern=^repo[1-4]
	repoName?: string @go(RepoName)

	// Network address of the PostgreSQL server to follow via streaming replication.
	// +optional
	host?: string @go(Host)

	// Network port of the PostgreSQL server to follow via streaming replication.
	// +optional
	// +kubebuilder:validation:Minimum=1024
	port?: null | int32 @go(Port,*int32)
}

// UserInterfaceSpec is a union of the supported PostgreSQL user interfaces.
#UserInterfaceSpec: {
	// Defines a pgAdmin user interface.
	pgAdmin?: null | #PGAdminPodSpec @go(PGAdmin,*PGAdminPodSpec)
}

// PostgresUserInterfaceStatus is a union of the supported PostgreSQL user
// interface statuses.
#PostgresUserInterfaceStatus: {
	// The state of the pgAdmin user interface.
	pgAdmin?: #PGAdminPodStatus @go(PGAdmin)
}

#PostgresAdditionalConfig: {
	files?: [...corev1.#VolumeProjection] @go(Files,[]corev1.VolumeProjection)
}

// PostgresCluster is the Schema for the postgresclusters API
#PostgresCluster: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta     @go(ObjectMeta)
	spec?:     #PostgresClusterSpec   @go(Spec)
	status?:   #PostgresClusterStatus @go(Status)
}

// PostgresClusterList contains a list of PostgresCluster
#PostgresClusterList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#PostgresCluster] @go(Items,[]PostgresCluster)
}

// MonitoringSpec is a union of the supported PostgreSQL Monitoring tools
#MonitoringSpec: {
	// +optional
	pgmonitor?: null | #PGMonitorSpec @go(PGMonitor,*PGMonitorSpec)
}

// MonitoringStatus is the current state of PostgreSQL cluster monitoring tool
// configuration
#MonitoringStatus: {
	// +optional
	exporterConfiguration?: string @go(ExporterConfiguration)
}

// PGMonitorSpec defines the desired state of the pgMonitor tool suite
#PGMonitorSpec: {
	// +optional
	exporter?: null | #ExporterSpec @go(Exporter,*ExporterSpec)
}

#ExporterSpec: {
	// Projected volumes containing custom PostgreSQL Exporter configuration.  Currently supports
	// the customization of PostgreSQL Exporter queries. If a "queries.yml" file is detected in
	// any volume projected using this field, it will be loaded using the "extend.query-path" flag:
	// https://github.com/prometheus-community/postgres_exporter#flags
	// Changing the values of field causes PostgreSQL and the exporter to restart.
	// +optional
	configuration?: [...corev1.#VolumeProjection] @go(Configuration,[]corev1.VolumeProjection)

	// Projected secret containing custom TLS certificates to encrypt output from the exporter
	// web server
	// +optional
	customTLSSecret?: null | corev1.#SecretProjection @go(CustomTLSSecret,*corev1.SecretProjection)

	// The image name to use for crunchy-postgres-exporter containers. The image may
	// also be set using the RELATED_IMAGE_PGEXPORTER environment variable.
	// +optional
	image?: string @go(Image)

	// Changing this value causes PostgreSQL and the exporter to restart.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)
}
