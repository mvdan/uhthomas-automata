// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cert-manager/cert-manager/pkg/apis/config/controller/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	sharedv1alpha1 "github.com/cert-manager/cert-manager/pkg/apis/config/shared/v1alpha1"
	logsapi "k8s.io/component-base/logs/api/v1"
)

#ControllerConfiguration: {
	metav1.#TypeMeta

	// kubeConfig is the kubeconfig file used to connect to the Kubernetes apiserver.
	// If not specified, the controller will attempt to load the in-cluster-config.
	kubeConfig?: string @go(KubeConfig)

	// apiServerHost is used to override the API server connection address.
	// Deprecated: use `kubeConfig` instead.
	apiServerHost?: string @go(APIServerHost)

	// Indicates the maximum queries-per-second requests to the Kubernetes apiserver
	// TODO: floats are not recommended. Maybe we should use resource.Quantity? https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
	kubernetesAPIQPS?: null | float32 @go(KubernetesAPIQPS,*float32)

	// The maximum burst queries-per-second of requests sent to the Kubernetes apiserver
	kubernetesAPIBurst?: null | int32 @go(KubernetesAPIBurst,*int32)

	// If set, this limits the scope of cert-manager to a single namespace and
	// ClusterIssuers are disabled. If not specified, all namespaces will be
	// watched"
	namespace?: string @go(Namespace)

	// Namespace to store resources owned by cluster scoped resources such as ClusterIssuer in.
	clusterResourceNamespace?: string @go(ClusterResourceNamespace)

	// LeaderElectionConfig configures the behaviour of the leader election
	leaderElectionConfig: #LeaderElectionConfig @go(LeaderElectionConfig)

	// A list of controllers to enable.
	// ['*'] enables all controllers,
	// ['foo'] enables only the foo controller
	// ['*', '-foo'] disables the controller named foo.
	controllers?: [...string] @go(Controllers,[]string)

	// Whether an issuer may make use of ambient credentials. 'Ambient
	// Credentials' are credentials drawn from the environment, metadata services,
	// or local files which are not explicitly configured in the Issuer API
	// object. When this flag is enabled, the following sources for
	// credentials are also used: AWS - All sources the Go SDK defaults to,
	// notably including any EC2 IAM roles available via instance metadata.
	issuerAmbientCredentials?: null | bool @go(IssuerAmbientCredentials,*bool)

	// Whether a cluster-issuer may make use of ambient credentials for issuers.
	// 'Ambient Credentials' are credentials drawn from the environment, metadata
	// services, or local files which are not explicitly configured in the
	// ClusterIssuer API object. When this flag is enabled, the following sources
	// for credentials are also used: AWS - All sources the Go SDK defaults to,
	// notably including any EC2 IAM roles available via instance metadata.
	clusterIssuerAmbientCredentials?: null | bool @go(ClusterIssuerAmbientCredentials,*bool)

	// Whether to set the certificate resource as an owner of secret where the
	// tls certificate is stored. When this flag is enabled, the secret will be
	// automatically removed when the certificate resource is deleted.
	enableCertificateOwnerRef?: null | bool @go(EnableCertificateOwnerRef,*bool)

	// Whether gateway API integration is enabled within cert-manager. The
	// ExperimentalGatewayAPISupport feature gate must also be enabled (default
	// as of 1.15).
	enableGatewayAPI?: null | bool @go(EnableGatewayAPI,*bool)

	// Specify which annotations should/shouldn't be copied from Certificate to
	// CertificateRequest and Order, as well as from CertificateSigningRequest to
	// Order, by passing a list of annotation key prefixes. A prefix starting with
	// a dash(-) specifies an annotation that shouldn't be copied. Example:
	// '*,-kubectl.kuberenetes.io/'- all annotations will be copied apart from the
	// ones where the key is prefixed with 'kubectl.kubernetes.io/'.
	copiedAnnotationPrefixes?: [...string] @go(CopiedAnnotationPrefixes,[]string)

	// The number of concurrent workers for each controller.
	numberOfConcurrentWorkers?: null | int32 @go(NumberOfConcurrentWorkers,*int32)

	// The maximum number of challenges that can be scheduled as 'processing' at once.
	maxConcurrentChallenges?: null | int32 @go(MaxConcurrentChallenges,*int32)

	// The host and port that the metrics endpoint should listen on.
	metricsListenAddress?: string @go(MetricsListenAddress)

	// TLS config for the metrics endpoint
	metricsTLSConfig: sharedv1alpha1.#TLSConfig @go(MetricsTLSConfig)

	// The host and port address, separated by a ':', that the healthz server
	// should listen on.
	healthzListenAddress?: string @go(HealthzListenAddress)

	// Enable profiling for controller.
	enablePprof?: null | bool @go(EnablePprof,*bool)

	// The host and port that Go profiler should listen on, i.e localhost:6060.
	// Ensure that profiler is not exposed on a public address. Profiler will be
	// served at /debug/pprof.
	pprofAddress?: string @go(PprofAddress)

	// logging configures the logging behaviour of the controller.
	// https://pkg.go.dev/k8s.io/component-base@v0.27.3/logs/api/v1#LoggingConfiguration
	logging: logsapi.#LoggingConfiguration @go(Logging)

	// featureGates is a map of feature names to bools that enable or disable experimental
	// features.
	// +optional
	featureGates?: {[string]: bool} @go(FeatureGates,map[string]bool)

	// ingressShimConfig configures the behaviour of the ingress-shim controller
	ingressShimConfig?: #IngressShimConfig @go(IngressShimConfig)

	// acmeHTTP01Config configures the behaviour of the ACME HTTP01 challenge solver
	acmeHTTP01Config?: #ACMEHTTP01Config @go(ACMEHTTP01Config)

	// acmeDNS01Config configures the behaviour of the ACME DNS01 challenge solver
	acmeDNS01Config?: #ACMEDNS01Config @go(ACMEDNS01Config)
}

#LeaderElectionConfig: {
	sharedv1alpha1.#LeaderElectionConfig

	// Leader election healthz checks within this timeout period after the lease
	// expires will still return healthy.
	healthzTimeout?: null | sharedv1alpha1.#Duration @go(HealthzTimeout,*sharedv1alpha1.Duration)
}

#IngressShimConfig: {
	// Default issuer/certificates details consumed by ingress-shim
	// Name of the Issuer to use when the tls is requested but issuer name is
	// not specified on the ingress resource.
	defaultIssuerName?: string @go(DefaultIssuerName)

	// Kind of the Issuer to use when the TLS is requested but issuer kind is not
	// specified on the ingress resource.
	defaultIssuerKind?: string @go(DefaultIssuerKind)

	// Group of the Issuer to use when the TLS is requested but issuer group is
	// not specified on the ingress resource.
	defaultIssuerGroup?: string @go(DefaultIssuerGroup)

	// The annotation consumed by the ingress-shim controller to indicate a ingress
	// is requesting a certificate
	defaultAutoCertificateAnnotations?: [...string] @go(DefaultAutoCertificateAnnotations,[]string)
}

#ACMEHTTP01Config: {
	// The Docker image to use to solve ACME HTTP01 challenges. You most likely
	// will not need to change this parameter unless you are testing a new
	// feature or developing cert-manager.
	solverImage?: string @go(SolverImage)

	// Defines the resource request CPU size when spawning new ACME HTTP01
	// challenge solver pods.
	solverResourceRequestCPU?: string @go(SolverResourceRequestCPU)

	// Defines the resource request Memory size when spawning new ACME HTTP01
	// challenge solver pods.
	solverResourceRequestMemory?: string @go(SolverResourceRequestMemory)

	// Defines the resource limits CPU size when spawning new ACME HTTP01
	// challenge solver pods.
	solverResourceLimitsCPU?: string @go(SolverResourceLimitsCPU)

	// Defines the resource limits Memory size when spawning new ACME HTTP01
	// challenge solver pods.
	solverResourceLimitsMemory?: string @go(SolverResourceLimitsMemory)

	// Defines the ability to run the http01 solver as root for troubleshooting
	// issues
	solverRunAsNonRoot?: null | bool @go(SolverRunAsNonRoot,*bool)

	// A list of comma separated dns server endpoints used for
	// ACME HTTP01 check requests. This should be a list containing host and
	// port, for example ["8.8.8.8:53","8.8.4.4:53"]
	// Allows specifying a list of custom nameservers to perform HTTP01 checks on.
	solverNameservers?: [...string] @go(SolverNameservers,[]string)
}

#ACMEDNS01Config: {
	// Each nameserver can be either the IP address and port of a standard
	// recursive DNS server, or the endpoint to an RFC 8484 DNS over HTTPS
	// endpoint. For example, the following values are valid:
	//  - "8.8.8.8:53" (Standard DNS)
	//  - "https://1.1.1.1/dns-query" (DNS over HTTPS)
	recursiveNameservers?: [...string] @go(RecursiveNameservers,[]string)

	// When true, cert-manager will only ever query the configured DNS resolvers
	// to perform the ACME DNS01 self check. This is useful in DNS constrained
	// environments, where access to authoritative nameservers is restricted.
	// Enabling this option could cause the DNS01 self check to take longer
	// due to caching performed by the recursive nameservers.
	recursiveNameserversOnly?: null | bool @go(RecursiveNameserversOnly,*bool)

	// The duration the controller should wait between a propagation check. Despite
	// the name, this flag is used to configure the wait period for both DNS01 and
	// HTTP01 challenge propagation checks. For DNS01 challenges the propagation
	// check verifies that a TXT record with the challenge token has been created.
	// For HTTP01 challenges the propagation check verifies that the challenge
	// token is served at the challenge URL. This should be a valid duration
	// string, for example 180s or 1h
	checkRetryPeriod?: null | sharedv1alpha1.#Duration @go(CheckRetryPeriod,*sharedv1alpha1.Duration)
}
