// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go kubevirt.io/api/core/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sv1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/api/resource"
)

#DefaultGracePeriodSeconds: int64 & 30

// VirtualMachineInstance is *the* VirtualMachineInstance Definition. It represents a virtual machine in the runtime environment of kubernetes.
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VirtualMachineInstance: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// VirtualMachineInstance Spec contains the VirtualMachineInstance specification.
	spec: #VirtualMachineInstanceSpec @go(Spec)

	// Status is the high level overview of how the VirtualMachineInstance is doing. It contains information available to controllers and users.
	status?: #VirtualMachineInstanceStatus @go(Status)
}

// VirtualMachineInstanceList is a list of VirtualMachines
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstance] @go(Items,[]VirtualMachineInstance)
}

#EvictionStrategy: string // #enumEvictionStrategy

#enumEvictionStrategy:
	#EvictionStrategyNone |
	#EvictionStrategyLiveMigrate |
	#EvictionStrategyExternal

#StartStrategy: string // #enumStartStrategy

#enumStartStrategy:
	#StartStrategyPaused

#StartStrategyPaused: #StartStrategy & "Paused"

// VirtualMachineInstanceSpec is a description of a VirtualMachineInstance.
#VirtualMachineInstanceSpec: _

// VirtualMachineInstancePhaseTransitionTimestamp gives a timestamp in relation to when a phase is set on a vmi
#VirtualMachineInstancePhaseTransitionTimestamp: {
	// Phase is the status of the VirtualMachineInstance in kubernetes world. It is not the VirtualMachineInstance status, but partially correlates to it.
	phase?: #VirtualMachineInstancePhase @go(Phase)

	// PhaseTransitionTimestamp is the timestamp of when the phase change occurred
	phaseTransitionTimestamp?: metav1.#Time @go(PhaseTransitionTimestamp)
}

#TopologyHints: {
	tscFrequency?: null | int64 @go(TSCFrequency,*int64)
}

// VirtualMachineInstanceStatus represents information about the status of a VirtualMachineInstance. Status may trail the actual
// state of a system.
#VirtualMachineInstanceStatus: {
	// NodeName is the name where the VirtualMachineInstance is currently running.
	nodeName?: string @go(NodeName)

	// A brief CamelCase message indicating details about why the VMI is in this state. e.g. 'NodeUnresponsive'
	// +optional
	reason?: string @go(Reason)

	// Conditions are specific points in VirtualMachineInstance's pod runtime.
	conditions?: [...#VirtualMachineInstanceCondition] @go(Conditions,[]VirtualMachineInstanceCondition)

	// Phase is the status of the VirtualMachineInstance in kubernetes world. It is not the VirtualMachineInstance status, but partially correlates to it.
	phase?: #VirtualMachineInstancePhase @go(Phase)

	// PhaseTransitionTimestamp is the timestamp of when the last phase change occurred
	// +listType=atomic
	// +optional
	phaseTransitionTimestamps?: [...#VirtualMachineInstancePhaseTransitionTimestamp] @go(PhaseTransitionTimestamps,[]VirtualMachineInstancePhaseTransitionTimestamp)

	// Interfaces represent the details of available network interfaces.
	interfaces?: [...#VirtualMachineInstanceNetworkInterface] @go(Interfaces,[]VirtualMachineInstanceNetworkInterface)

	// Guest OS Information
	guestOSInfo?: #VirtualMachineInstanceGuestOSInfo @go(GuestOSInfo)

	// Represents the status of a live migration
	migrationState?: null | #VirtualMachineInstanceMigrationState @go(MigrationState,*VirtualMachineInstanceMigrationState)

	// Represents the method using which the vmi can be migrated: live migration or block migration
	migrationMethod?: #VirtualMachineInstanceMigrationMethod @go(MigrationMethod)

	// This represents the migration transport
	migrationTransport?: #VirtualMachineInstanceMigrationTransport @go(MigrationTransport)

	// The Quality of Service (QOS) classification assigned to the virtual machine instance based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
	// +optional
	qosClass?: null | k8sv1.#PodQOSClass @go(QOSClass,*k8sv1.PodQOSClass)

	// LauncherContainerImageVersion indicates what container image is currently active for the vmi.
	launcherContainerImageVersion?: string @go(LauncherContainerImageVersion)

	// EvacuationNodeName is used to track the eviction process of a VMI. It stores the name of the node that we want
	// to evacuate. It is meant to be used by KubeVirt core components only and can't be set or modified by users.
	// +optional
	evacuationNodeName?: string @go(EvacuationNodeName)

	// ActivePods is a mapping of pod UID to node name.
	// It is possible for multiple pods to be running for a single VMI during migration.
	activePods?: {[string]: string} @go(ActivePods,map[types.UID]string)

	// VolumeStatus contains the statuses of all the volumes
	// +optional
	// +listType=atomic
	volumeStatus?: [...#VolumeStatus] @go(VolumeStatus,[]VolumeStatus)

	// FSFreezeStatus is the state of the fs of the guest
	// it can be either frozen or thawed
	// +optional
	fsFreezeStatus?: string @go(FSFreezeStatus)

	// +optional
	topologyHints?: null | #TopologyHints @go(TopologyHints,*TopologyHints)

	//VirtualMachineRevisionName is used to get the vm revision of the vmi when doing
	// an online vm snapshot
	// +optional
	virtualMachineRevisionName?: string @go(VirtualMachineRevisionName)

	// RuntimeUser is used to determine what user will be used in launcher
	// +optional
	runtimeUser: uint64 @go(RuntimeUser)

	// VSOCKCID is used to track the allocated VSOCK CID in the VM.
	// +optional
	VSOCKCID?: null | uint32 @go(,*uint32)

	// SELinuxContext is the actual SELinux context of the virt-launcher pod
	// +optional
	selinuxContext?: string @go(SelinuxContext)
}

// PersistentVolumeClaimInfo contains the relavant information virt-handler needs cached about a PVC
#PersistentVolumeClaimInfo: {
	// AccessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	// +listType=atomic
	// +optional
	accessModes?: [...k8sv1.#PersistentVolumeAccessMode] @go(AccessModes,[]k8sv1.PersistentVolumeAccessMode)

	// VolumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	// +optional
	volumeMode?: null | k8sv1.#PersistentVolumeMode @go(VolumeMode,*k8sv1.PersistentVolumeMode)

	// Capacity represents the capacity set on the corresponding PVC status
	// +optional
	capacity?: k8sv1.#ResourceList @go(Capacity)

	// Requests represents the resources requested by the corresponding PVC spec
	// +optional
	requests?: k8sv1.#ResourceList @go(Requests)

	// Preallocated indicates if the PVC's storage is preallocated or not
	// +optional
	preallocated?: bool @go(Preallocated)
}

// VolumeStatus represents information about the status of volumes attached to the VirtualMachineInstance.
#VolumeStatus: {
	// Name is the name of the volume
	name: string @go(Name)

	// Target is the target name used when adding the volume to the VM, eg: vda
	target: string @go(Target)

	// Phase is the phase
	phase?: #VolumePhase @go(Phase)

	// Reason is a brief description of why we are in the current hotplug volume phase
	reason?: string @go(Reason)

	// Message is a detailed message about the current hotplug volume phase
	message?: string @go(Message)

	// PersistentVolumeClaimInfo is information about the PVC that handler requires during start flow
	persistentVolumeClaimInfo?: null | #PersistentVolumeClaimInfo @go(PersistentVolumeClaimInfo,*PersistentVolumeClaimInfo)

	// If the volume is hotplug, this will contain the hotplug status.
	hotplugVolume?: null | #HotplugVolumeStatus @go(HotplugVolume,*HotplugVolumeStatus)

	// Represents the size of the volume
	size?: int64 @go(Size)

	// If the volume is memorydump volume, this will contain the memorydump info.
	memoryDumpVolume?: null | #DomainMemoryDumpInfo @go(MemoryDumpVolume,*DomainMemoryDumpInfo)
}

// DomainMemoryDumpInfo represents the memory dump information
#DomainMemoryDumpInfo: {
	// StartTimestamp is the time when the memory dump started
	startTimestamp?: null | metav1.#Time @go(StartTimestamp,*metav1.Time)

	// EndTimestamp is the time when the memory dump completed
	endTimestamp?: null | metav1.#Time @go(EndTimestamp,*metav1.Time)

	// ClaimName is the name of the pvc the memory was dumped to
	claimName?: string @go(ClaimName)

	// TargetFileName is the name of the memory dump output
	targetFileName?: string @go(TargetFileName)
}

// HotplugVolumeStatus represents the hotplug status of the volume
#HotplugVolumeStatus: {
	// AttachPodName is the name of the pod used to attach the volume to the node.
	attachPodName?: string @go(AttachPodName)

	// AttachPodUID is the UID of the pod used to attach the volume to the node.
	attachPodUID?: types.#UID @go(AttachPodUID)
}

// VolumePhase indicates the current phase of the hotplug process.
#VolumePhase: string // #enumVolumePhase

#enumVolumePhase:
	#VolumePending |
	#VolumeBound |
	#HotplugVolumeAttachedToNode |
	#HotplugVolumeMounted |
	#VolumeReady |
	#HotplugVolumeDetaching |
	#HotplugVolumeUnMounted |
	#MemoryDumpVolumeCompleted |
	#MemoryDumpVolumeInProgress |
	#MemoryDumpVolumeFailed

// VolumePending means the Volume is pending and cannot be attached to the node yet.
#VolumePending: #VolumePhase & "Pending"

// VolumeBound means the Volume is bound and can be attach to the node.
#VolumeBound: #VolumePhase & "Bound"

// HotplugVolumeAttachedToNode means the volume has been attached to the node.
#HotplugVolumeAttachedToNode: #VolumePhase & "AttachedToNode"

// HotplugVolumeMounted means the volume has been attached to the node and is mounted to the virt-launcher pod.
#HotplugVolumeMounted: #VolumePhase & "MountedToPod"

// VolumeReady means the volume is ready to be used by the VirtualMachineInstance.
#VolumeReady: #VolumePhase & "Ready"

// HotplugVolumeDetaching means the volume is being detached from the node, and the attachment pod is being removed.
#HotplugVolumeDetaching: #VolumePhase & "Detaching"

// HotplugVolumeUnMounted means the volume has been unmounted from the virt-launcer pod.
#HotplugVolumeUnMounted: #VolumePhase & "UnMountedFromPod"

// MemoryDumpVolumeCompleted means that the requested memory dump was completed and the dump is ready in the volume
#MemoryDumpVolumeCompleted: #VolumePhase & "MemoryDumpCompleted"

// MemoryDumpVolumeInProgress means that the volume for the memory dump was attached, and now the command is being triggered
#MemoryDumpVolumeInProgress: #VolumePhase & "MemoryDumpInProgress"

// MemoryDumpVolumeInProgress means that the volume for the memory dump was attached, and now the command is being triggered
#MemoryDumpVolumeFailed: #VolumePhase & "MemoryDumpFailed"

#VirtualMachineInstanceConditionType: string // #enumVirtualMachineInstanceConditionType

#enumVirtualMachineInstanceConditionType:
	#VirtualMachineInstanceProvisioning |
	#VirtualMachineInstanceReady |
	#VirtualMachineInstanceSynchronized |
	#VirtualMachineInstancePaused |
	#VirtualMachineInstanceAgentConnected |
	#VirtualMachineInstanceAccessCredentialsSynchronized |
	#VirtualMachineInstanceUnsupportedAgent |
	#VirtualMachineInstanceIsMigratable

// Provisioning means, a VMI depends on DataVolumes which are in Pending/WaitForFirstConsumer status,
// and some actions are taken to provision the PVCs for the DataVolumes
#VirtualMachineInstanceProvisioning: #VirtualMachineInstanceConditionType & "Provisioning"

// Ready means the VMI is able to service requests and should be added to the
// load balancing pools of all matching services.
#VirtualMachineInstanceReady: #VirtualMachineInstanceConditionType & "Ready"

// If there happens any error while trying to synchronize the VirtualMachineInstance with the Domain,
// this is reported as false.
#VirtualMachineInstanceSynchronized: #VirtualMachineInstanceConditionType & "Synchronized"

// If the VMI was paused by the user, this is reported as true.
#VirtualMachineInstancePaused: #VirtualMachineInstanceConditionType & "Paused"

// Reflects whether the QEMU guest agent is connected through the channel
#VirtualMachineInstanceAgentConnected: #VirtualMachineInstanceConditionType & "AgentConnected"

// Reflects whether the QEMU guest agent updated access credentials successfully
#VirtualMachineInstanceAccessCredentialsSynchronized: #VirtualMachineInstanceConditionType & "AccessCredentialsSynchronized"

// Reflects whether the QEMU guest agent is connected through the channel
#VirtualMachineInstanceUnsupportedAgent: #VirtualMachineInstanceConditionType & "AgentVersionNotSupported"

// Indicates whether the VMI is live migratable
#VirtualMachineInstanceIsMigratable: #VirtualMachineInstanceConditionType & "LiveMigratable"

// Reason means that VMI is not live migratioable because of it's disks collection
#VirtualMachineInstanceReasonDisksNotMigratable: "DisksNotLiveMigratable"

// Reason means that VMI is not live migratioable because of it's network interfaces collection
#VirtualMachineInstanceReasonInterfaceNotMigratable: "InterfaceNotLiveMigratable"

// Reason means that VMI is not live migratioable because it uses hotplug
#VirtualMachineInstanceReasonHotplugNotMigratable: "HotplugNotLiveMigratable"

// Reason means that VMI is not live migratioable because of it's CPU mode
#VirtualMachineInstanceReasonCPUModeNotMigratable: "CPUModeLiveMigratable"

// Reason means that VMI is not live migratable because it uses virtiofs
#VirtualMachineInstanceReasonVirtIOFSNotMigratable: "VirtIOFSNotLiveMigratable"

// Reason means that VMI is not live migratable because it uses PCI host devices
#VirtualMachineInstanceReasonHostDeviceNotMigratable: "HostDeviceNotLiveMigratable"

// Reason means that VMI is not live migratable because it uses Secure Encrypted Virtualization (SEV)
#VirtualMachineInstanceReasonSEVNotMigratable: "SEVNotLiveMigratable"

// Reason means that VMI is not live migratable because it uses HyperV Reenlightenment while TSC Frequency is not available
#VirtualMachineInstanceReasonNoTSCFrequencyMigratable: "NoTSCFrequencyNotLiveMigratable"

// Reason means that VMI is not live migratable because it uses dedicated CPU and emulator thread isolation
#VirtualMachineInstanceReasonDedicatedCPU: "DedicatedCPUNotLiveMigratable"

// PodTerminatingReason indicates on the Ready condition on the VMI if the underlying pod is terminating
#PodTerminatingReason: "PodTerminating"

// PodNotExistsReason indicates on the Ready condition on the VMI if the underlying pod does not exist
#PodNotExistsReason: "PodNotExists"

// PodConditionMissingReason indicates on the Ready condition on the VMI if the underlying pod does not report a Ready condition
#PodConditionMissingReason: "PodConditionMissing"

// GuestNotRunningReason indicates on the Ready condition on the VMI if the underlying guest VM is not running
#GuestNotRunningReason: "GuestNotRunning"

#VirtualMachineInstanceMigrationConditionType: string // #enumVirtualMachineInstanceMigrationConditionType

#enumVirtualMachineInstanceMigrationConditionType:
	#VirtualMachineInstanceMigrationAbortRequested

// VirtualMachineInstanceMigrationAbortRequested indicates that live migration abort has been requested
#VirtualMachineInstanceMigrationAbortRequested: #VirtualMachineInstanceMigrationConditionType & "migrationAbortRequested"

#VirtualMachineInstanceCondition: {
	type:   #VirtualMachineInstanceConditionType @go(Type)
	status: k8sv1.#ConditionStatus               @go(Status)

	// +nullable
	lastProbeTime?: metav1.#Time @go(LastProbeTime)

	// +nullable
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
	reason?:             string       @go(Reason)
	message?:            string       @go(Message)
}

#VirtualMachineInstanceMigrationCondition: {
	type:   #VirtualMachineInstanceMigrationConditionType @go(Type)
	status: k8sv1.#ConditionStatus                        @go(Status)

	// +nullable
	lastProbeTime?: metav1.#Time @go(LastProbeTime)

	// +nullable
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
	reason?:             string       @go(Reason)
	message?:            string       @go(Message)
}

#VirtualMachineInstanceNetworkInterface: {
	// IP address of a Virtual Machine interface. It is always the first item of
	// IPs
	ipAddress?: string @go(IP)

	// Hardware address of a Virtual Machine interface
	mac?: string @go(MAC)

	// Name of the interface, corresponds to name of the network assigned to the interface
	name?: string @go(Name)

	// List of all IP addresses of a Virtual Machine interface
	ipAddresses?: [...string] @go(IPs,[]string)

	// The interface name inside the Virtual Machine
	interfaceName?: string @go(InterfaceName)

	// Specifies the origin of the interface data collected. values: domain, guest-agent, or both
	infoSource?: string @go(InfoSource)

	// Specifies how many queues are allocated by MultiQueue
	queueCount?: int32 @go(QueueCount)
}

#VirtualMachineInstanceGuestOSInfo: {
	// Name of the Guest OS
	name?: string @go(Name)

	// Guest OS Kernel Release
	kernelRelease?: string @go(KernelRelease)

	// Guest OS Version
	version?: string @go(Version)

	// Guest OS Pretty Name
	prettyName?: string @go(PrettyName)

	// Version ID of the Guest OS
	versionId?: string @go(VersionID)

	// Kernel version of the Guest OS
	kernelVersion?: string @go(KernelVersion)

	// Machine type of the Guest OS
	machine?: string @go(Machine)

	// Guest OS Id
	id?: string @go(ID)
}

// MigrationConfigSource indicates the source of migration configuration.
//
// +k8s:openapi-gen=true
#MigrationConfigSource: string

// +k8s:openapi-gen=true
#VirtualMachineInstanceMigrationState: {
	// The time the migration action began
	// +nullable
	startTimestamp?: null | metav1.#Time @go(StartTimestamp,*metav1.Time)

	// The time the migration action ended
	// +nullable
	endTimestamp?: null | metav1.#Time @go(EndTimestamp,*metav1.Time)

	// The Target Node has seen the Domain Start Event
	targetNodeDomainDetected?: bool @go(TargetNodeDomainDetected)

	// The address of the target node to use for the migration
	targetNodeAddress?: string @go(TargetNodeAddress)

	// The list of ports opened for live migration on the destination node
	targetDirectMigrationNodePorts?: {[string]: int} @go(TargetDirectMigrationNodePorts,map[string]int)

	// The target node that the VMI is moving to
	targetNode?: string @go(TargetNode)

	// The target pod that the VMI is moving to
	targetPod?: string @go(TargetPod)

	// The UID of the target attachment pod for hotplug volumes
	targetAttachmentPodUID?: types.#UID @go(TargetAttachmentPodUID)

	// The source node that the VMI originated on
	sourceNode?: string @go(SourceNode)

	// Indicates the migration completed
	completed?: bool @go(Completed)

	// Indicates that the migration failed
	failed?: bool @go(Failed)

	// Indicates that the migration has been requested to abort
	abortRequested?: bool @go(AbortRequested)

	// Indicates the final status of the live migration abortion
	abortStatus?: #MigrationAbortStatus @go(AbortStatus)

	// The VirtualMachineInstanceMigration object associated with this migration
	migrationUid?: types.#UID @go(MigrationUID)

	// Lets us know if the vmi is currently running pre or post copy migration
	mode?: #MigrationMode @go(Mode)

	// Name of the migration policy. If string is empty, no policy is matched
	migrationPolicyName?: null | string @go(MigrationPolicyName,*string)

	// Migration configurations to apply
	migrationConfiguration?: null | #MigrationConfiguration @go(MigrationConfiguration,*MigrationConfiguration)

	// If the VMI requires dedicated CPUs, this field will
	// hold the dedicated CPU set on the target node
	// +listType=atomic
	targetCPUSet?: [...int] @go(TargetCPUSet,[]int)

	// If the VMI requires dedicated CPUs, this field will
	// hold the numa topology on the target node
	targetNodeTopology?: string @go(TargetNodeTopology)
}

#MigrationAbortStatus: string // #enumMigrationAbortStatus

#enumMigrationAbortStatus:
	#MigrationAbortSucceeded |
	#MigrationAbortFailed |
	#MigrationAbortInProgress

// MigrationAbortSucceeded means that the VirtualMachineInstance live migration has been aborted
#MigrationAbortSucceeded: #MigrationAbortStatus & "Succeeded"

// MigrationAbortFailed means that the vmi live migration has failed to be abort
#MigrationAbortFailed: #MigrationAbortStatus & "Failed"

// MigrationAbortInProgress mean that the vmi live migration is aborting
#MigrationAbortInProgress: #MigrationAbortStatus & "Aborting"

#MigrationMode: string // #enumMigrationMode

#enumMigrationMode:
	#MigrationPreCopy |
	#MigrationPostCopy

// MigrationPreCopy means the VMI migrations that is currently running is in pre copy mode
#MigrationPreCopy: #MigrationMode & "PreCopy"

// MigrationPostCopy means the VMI migrations that is currently running is in post copy mode
#MigrationPostCopy: #MigrationMode & "PostCopy"

#VirtualMachineInstanceMigrationTransport: string // #enumVirtualMachineInstanceMigrationTransport

#enumVirtualMachineInstanceMigrationTransport:
	#MigrationTransportUnix

// MigrationTransportUnix means that the VMI will be migrated using the unix URI
#MigrationTransportUnix: #VirtualMachineInstanceMigrationTransport & "Unix"

#VirtualMachineInstanceMigrationMethod: string // #enumVirtualMachineInstanceMigrationMethod

#enumVirtualMachineInstanceMigrationMethod:
	#BlockMigration |
	#LiveMigration

// BlockMigration means that all VirtualMachineInstance disks should be copied over to the destination host
#BlockMigration: #VirtualMachineInstanceMigrationMethod & "BlockMigration"

// LiveMigration means that VirtualMachineInstance disks will not be copied over to the destination host
#LiveMigration: #VirtualMachineInstanceMigrationMethod & "LiveMigration"

// VirtualMachineInstancePhase is a label for the condition of a VirtualMachineInstance at the current time.
#VirtualMachineInstancePhase: string // #enumVirtualMachineInstancePhase

#enumVirtualMachineInstancePhase:
	#VmPhaseUnset |
	#Pending |
	#Scheduling |
	#Scheduled |
	#Running |
	#Succeeded |
	#Failed |
	#Unknown

//When a VirtualMachineInstance Object is first initialized and no phase, or Pending is present.
#VmPhaseUnset: #VirtualMachineInstancePhase & ""

// Pending means the VirtualMachineInstance has been accepted by the system.
#Pending: #VirtualMachineInstancePhase & "Pending"

// A target Pod exists but is not yet scheduled and in running state.
#Scheduling: #VirtualMachineInstancePhase & "Scheduling"

// A target pod was scheduled and the system saw that Pod in runnig state.
// Here is where the responsibility of virt-controller ends and virt-handler takes over.
#Scheduled: #VirtualMachineInstancePhase & "Scheduled"

// Running means the pod has been bound to a node and the VirtualMachineInstance is started.
#Running: #VirtualMachineInstancePhase & "Running"

// Succeeded means that the VirtualMachineInstance stopped voluntarily, e.g. reacted to SIGTERM or shutdown was invoked from
// inside the VirtualMachineInstance.
#Succeeded: #VirtualMachineInstancePhase & "Succeeded"

// Failed means that the vmi crashed, disappeared unexpectedly or got deleted from the cluster before it was ever started.
#Failed: #VirtualMachineInstancePhase & "Failed"

// Unknown means that for some reason the state of the VirtualMachineInstance could not be obtained, typically due
// to an error in communicating with the host of the VirtualMachineInstance.
#Unknown: #VirtualMachineInstancePhase & "Unknown"

// AppLabel and AppName labels marks resources that belong to KubeVirt. An optional value
// may indicate which specific KubeVirt component a resource belongs to.
#AppLabel: "kubevirt.io"
#AppName:  "name"

// This annotation is used to match virtual machine instances represented as
// libvirt XML domains with their pods. Among other things, the annotation is
// used to detect virtual machines with dead pods. Used on Pod.
#DomainAnnotation: "kubevirt.io/domain"

// Represents the name of the migration job this target pod is associated with
#MigrationJobNameAnnotation:                    "kubevirt.io/migrationJobName"
#ControllerAPILatestVersionObservedAnnotation:  "kubevirt.io/latest-observed-api-version"
#ControllerAPIStorageVersionObservedAnnotation: "kubevirt.io/storage-observed-api-version"

// Used by functional tests to force a VMI to fail the migration internally within launcher
#FuncTestForceLauncherMigrationFailureAnnotation: "kubevirt.io/func-test-force-launcher-migration-failure"

// Used by functional tests to prevent virt launcher from finishing the target pod preparation.
#FuncTestBlockLauncherPrepareMigrationTargetAnnotation: "kubevirt.io/func-test-block-migration-target-preparation"

// Used by functional tests set custom image on migration target pod
#FuncTestMigrationTargetImageOverrideAnnotation: "kubevirt.io/func-test-migration-target-image-override"

// Used by functional tests to simulate virt-launcher crash looping
#FuncTestLauncherFailFastAnnotation: "kubevirt.io/func-test-virt-launcher-fail-fast"

// Used by functional tests to ignore backoff applied to migrations
#FuncTestForceIgnoreMigrationBackoffAnnotation: "kubevirt.io/func-test-ignore-migration-backoff"

// This label is used to match virtual machine instance IDs with pods.
// Similar to kubevirt.io/domain. Used on Pod.
// Internal use only.
#CreatedByLabel: "kubevirt.io/created-by"

// This label is used to indicate that this pod is the target of a migration job.
#MigrationJobLabel: "kubevirt.io/migrationJobUID"

// This label indicates the migration name that a PDB is protecting.
#MigrationNameLabel: "kubevirt.io/migrationName"

// This label describes which cluster node runs the virtual machine
// instance. Needed because with CRDs we can't use field selectors. Used on
// VirtualMachineInstance.
#NodeNameLabel: "kubevirt.io/nodeName"

// This label describes which cluster node runs the target Pod for a Virtual
// Machine Instance migration job. Needed because with CRDs we can't use field
// selectors. Used on VirtualMachineInstance.
#MigrationTargetNodeNameLabel: "kubevirt.io/migrationTargetNodeName"

// This annotation indicates that a migration is the result of an
// automated evacuation
#EvacuationMigrationAnnotation: "kubevirt.io/evacuationMigration"

// This annotation indicates that a migration is the result of an
// automated workload update
#WorkloadUpdateMigrationAnnotation: "kubevirt.io/workloadUpdateMigration"

// This label declares whether a particular node is available for
// scheduling virtual machine instances on it. Used on Node.
#NodeSchedulable: "kubevirt.io/schedulable"

// This annotation is regularly updated by virt-handler to help determine
// if a particular node is alive and hence should be available for new
// virtual machine instance scheduling. Used on Node.
#VirtHandlerHeartbeat: "kubevirt.io/heartbeat"

// This label indicates what launcher image a VMI is currently running with.
#OutdatedLauncherImageLabel: "kubevirt.io/outdatedLauncherImage"

// Namespace recommended by Kubernetes for commonly recognized labels
#AppLabelPrefix: "app.kubernetes.io"

// This label is commonly used by 3rd party management tools to identify
// an application's name.
#AppNameLabel: "app.kubernetes.io/name"

// This label is commonly used by 3rd party management tools to identify
// an application's version.
#AppVersionLabel: "app.kubernetes.io/version"

// This label is commonly used by 3rd party management tools to identify
// a higher level application.
#AppPartOfLabel: "app.kubernetes.io/part-of"

// This label is commonly used by 3rd party management tools to identify
// the component this application is a part of.
#AppComponentLabel: "app.kubernetes.io/component"

// This label identifies each resource as part of KubeVirt
#AppComponent: "kubevirt"

// This label will be set on all resources created by the operator
#ManagedByLabel:                 "app.kubernetes.io/managed-by"
#ManagedByLabelOperatorValue:    "virt-operator"
#ManagedByLabelOperatorOldValue: "kubevirt-operator"

// This annotation represents the kubevirt version for an install strategy configmap.
#InstallStrategyVersionAnnotation: "kubevirt.io/install-strategy-version"

// This annotation represents the kubevirt registry used for an install strategy configmap.
#InstallStrategyRegistryAnnotation: "kubevirt.io/install-strategy-registry"

// This annotation represents the kubevirt deployment identifier used for an install strategy configmap.
#InstallStrategyIdentifierAnnotation: "kubevirt.io/install-strategy-identifier"

// This annotation shows the enconding used for the manifests in the Install Strategy ConfigMap.
#InstallStrategyConfigMapEncoding: "kubevirt.io/install-strategy-cm-encoding"

// This annotation is a hash of all customizations that live under spec.CustomizeComponents
#KubeVirtCustomizeComponentAnnotationHash: "kubevirt.io/customizer-identifier"

// This annotation represents the kubevirt generation that was used to create a resource
#KubeVirtGenerationAnnotation: "kubevirt.io/generation"

// This annotation represents that this object is for temporary use during updates
#EphemeralBackupObject: "kubevirt.io/ephemeral-backup-object"

// This annotation represents that the annotated object is for temporary use during pod/volume provisioning
#EphemeralProvisioningObject: "kubevirt.io/ephemeral-provisioning"

// This label indicates the object is a part of the install strategy retrieval process.
#InstallStrategyLabel: "kubevirt.io/install-strategy"

// Set by virt-operator to coordinate component deletion
#VirtOperatorComponentFinalizer: "kubevirt.io/virtOperatorFinalizer"

// Set by VMI controller to ensure VMIs are processed during deletion
#VirtualMachineInstanceFinalizer: "foregroundDeleteVirtualMachine"

// Set By VM controller on VMIs to ensure VMIs are processed by VM controller during deletion
#VirtualMachineControllerFinalizer:        "kubevirt.io/virtualMachineControllerFinalize"
#VirtualMachineInstanceMigrationFinalizer: "kubevirt.io/migrationJobFinalize"
#CPUManager:                               "cpumanager"

// This annotation is used to inject ignition data
// Used on VirtualMachineInstance.
#IgnitionAnnotation:           "kubevirt.io/ignitiondata"
#PlacePCIDevicesOnRootComplex: "kubevirt.io/placePCIDevicesOnRootComplex"

// This label represents supported cpu features on the node
#CPUFeatureLabel: "cpu-feature.node.kubevirt.io/"

// This label represents supported cpu models on the node
#CPUModelLabel:                  "cpu-model.node.kubevirt.io/"
#SupportedHostModelMigrationCPU: "cpu-model-migration.node.kubevirt.io/"
#CPUTimerLabel:                  "cpu-timer.node.kubevirt.io/"

// This label represents supported HyperV features on the node
#HypervLabel: "hyperv.node.kubevirt.io/"

// This label represents vendor of cpu model on the node
#CPUModelVendorLabel: "cpu-vendor.node.kubevirt.io/"
#VirtIO:              "virtio"

// This label represents the host model CPU name
#HostModelCPULabel: "host-model-cpu.node.kubevirt.io/"

// This label represents the host model required features
#HostModelRequiredFeaturesLabel: "host-model-required-features.node.kubevirt.io/"
#NodeHostModelIsObsoleteLabel:   "node-labeller.kubevirt.io/obsolete-host-model"
#LabellerSkipNodeAnnotation:     "node-labeller.kubevirt.io/skip-node"
#VirtualMachineLabel:            "kubevirt.io/vm"
#MemfdMemoryBackend:             "kubevirt.io/memfd"
#MigrationSelectorLabel:         "kubevirt.io/vmi-name"

// This annotation represents vmi running nonroot implementation
#DeprecatedNonRootVMIAnnotation: "kubevirt.io/nonroot"

// This annotation is to keep virt launcher container alive when an VMI encounters a failure for debugging purpose
#KeepLauncherAfterFailureAnnotation: "kubevirt.io/keep-launcher-alive-after-failure"

// MigrationTransportUnixAnnotation means that the VMI will be migrated using the unix URI
#MigrationTransportUnixAnnotation: "kubevirt.io/migrationTransportUnix"

// MigrationUnschedulablePodTimeoutSecondsAnnotation represents a custom timeout period used for unschedulable target pods
// This exists for functional testing
#MigrationUnschedulablePodTimeoutSecondsAnnotation: "kubevirt.io/migrationUnschedulablePodTimeoutSeconds"

// MigrationPendingPodTimeoutSecondsAnnotation represents a custom timeout period used for target pods stuck in pending for any reason
// This exists for functional testing
#MigrationPendingPodTimeoutSecondsAnnotation: "kubevirt.io/migrationPendingPodTimeoutSeconds"

// CustomLibvirtLogFiltersAnnotation can be used to customized libvirt log filters. Example value could be
// "3:remote 4:event 3:util.json 3:util.object 3:util.dbus 3:util.netlink 3:node_device 3:rpc 3:access 1:*".
// For more info: https://libvirt.org/kbase/debuglogs.html
#CustomLibvirtLogFiltersAnnotation: "kubevirt.io/libvirt-log-filters"

// RealtimeLabel marks the node as capable of running realtime workloads
#RealtimeLabel: "kubevirt.io/realtime"

// VirtualMachineUnpaused is a custom pod condition set for the virt-launcher pod.
// It's used as a readiness gate to prevent paused VMs from being marked as ready.
#VirtualMachineUnpaused: k8sv1.#PodConditionType & "kubevirt.io/virtual-machine-unpaused"

// SEVLabel marks the node as capable of running workloads with SEV
#SEVLabel: "kubevirt.io/sev"

// InstancetypeAnnotation is the name of a VirtualMachineInstancetype
#InstancetypeAnnotation: "kubevirt.io/instancetype-name"

// ClusterInstancetypeAnnotation is the name of a VirtualMachineClusterInstancetype
#ClusterInstancetypeAnnotation: "kubevirt.io/cluster-instancetype-name"

// InstancetypeAnnotation is the name of a VirtualMachinePreference
#PreferenceAnnotation: "kubevirt.io/preference-name"

// ClusterInstancetypeAnnotation is the name of a VirtualMachinePreferenceInstancetype
#ClusterPreferenceAnnotation: "kubevirt.io/cluster-preference-name"

// VirtualMachinePoolRevisionName is used to store the vmpool revision's name this object
// originated from.
#VirtualMachinePoolRevisionName: "kubevirt.io/vm-pool-revision-name"

// VirtualMachineNameLabel is the name of the Virtual Machine
#VirtualMachineNameLabel: "vm.kubevirt.io/name"

// PVCMemoryDumpAnnotation is the name of the memory dump representing the vm name,
// pvc name and the timestamp the memory dump was collected
#PVCMemoryDumpAnnotation: "kubevirt.io/memory-dump"

#SyncEvent: string // #enumSyncEvent

#enumSyncEvent:
	#Created |
	#Deleted |
	#PresetFailed |
	#Override |
	#Started |
	#ShuttingDown |
	#Stopped |
	#PreparingTarget |
	#Migrating |
	#Migrated |
	#SyncFailed |
	#Resumed |
	#AccessCredentialsSyncFailed |
	#AccessCredentialsSyncSuccess

#Created:                      #SyncEvent & "Created"
#Deleted:                      #SyncEvent & "Deleted"
#PresetFailed:                 #SyncEvent & "PresetFailed"
#Override:                     #SyncEvent & "Override"
#Started:                      #SyncEvent & "Started"
#ShuttingDown:                 #SyncEvent & "ShuttingDown"
#Stopped:                      #SyncEvent & "Stopped"
#PreparingTarget:              #SyncEvent & "PreparingTarget"
#Migrating:                    #SyncEvent & "Migrating"
#Migrated:                     #SyncEvent & "Migrated"
#SyncFailed:                   #SyncEvent & "SyncFailed"
#Resumed:                      #SyncEvent & "Resumed"
#AccessCredentialsSyncFailed:  #SyncEvent & "AccessCredentialsSyncFailed"
#AccessCredentialsSyncSuccess: #SyncEvent & "AccessCredentialsSyncSuccess"

#VMISelector: {
	// Name of the VirtualMachineInstance to migrate
	name: string @go(Name)
}

// VirtualMachineInstance is *the* VirtualMachineInstance Definition. It represents a virtual machine in the runtime environment of kubernetes.
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VirtualMachineInstanceReplicaSet: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// VirtualMachineInstance Spec contains the VirtualMachineInstance specification.
	spec: #VirtualMachineInstanceReplicaSetSpec @go(Spec)

	// Status is the high level overview of how the VirtualMachineInstance is doing. It contains information available to controllers and users.
	// +nullable
	status?: #VirtualMachineInstanceReplicaSetStatus @go(Status)
}

// VMIList is a list of VMIs
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceReplicaSetList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstanceReplicaSet] @go(Items,[]VirtualMachineInstanceReplicaSet)
}

#VirtualMachineInstanceReplicaSetSpec: {
	// Number of desired pods. This is a pointer to distinguish between explicit
	// zero and not specified. Defaults to 1.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// Label selector for pods. Existing ReplicaSets whose pods are
	// selected by this will be the ones affected by this deployment.
	selector?: null | metav1.#LabelSelector @go(Selector,*metav1.LabelSelector)

	// Template describes the pods that will be created.
	template?: null | #VirtualMachineInstanceTemplateSpec @go(Template,*VirtualMachineInstanceTemplateSpec)

	// Indicates that the replica set is paused.
	// +optional
	paused?: bool @go(Paused) @protobuf(7,varint,opt)
}

#VirtualMachineInstanceReplicaSetStatus: {
	// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
	// +optional
	replicas?: int32 @go(Replicas) @protobuf(2,varint,opt)

	// The number of ready replicas for this replica set.
	// +optional
	readyReplicas?: int32 @go(ReadyReplicas) @protobuf(4,varint,opt)
	conditions?: [...#VirtualMachineInstanceReplicaSetCondition] @go(Conditions,[]VirtualMachineInstanceReplicaSetCondition)

	// Canonical form of the label selector for HPA which consumes it through the scale subresource.
	labelSelector?: string @go(LabelSelector)
}

#VirtualMachineInstanceReplicaSetCondition: {
	type:   #VirtualMachineInstanceReplicaSetConditionType @go(Type)
	status: k8sv1.#ConditionStatus                         @go(Status)

	// +nullable
	lastProbeTime?: metav1.#Time @go(LastProbeTime)

	// +nullable
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
	reason?:             string       @go(Reason)
	message?:            string       @go(Message)
}

#VirtualMachineInstanceReplicaSetConditionType: string // #enumVirtualMachineInstanceReplicaSetConditionType

#enumVirtualMachineInstanceReplicaSetConditionType:
	#VirtualMachineInstanceReplicaSetReplicaFailure |
	#VirtualMachineInstanceReplicaSetReplicaPaused

// VirtualMachineInstanceReplicaSetReplicaFailure is added in a replica set when one of its vmis
// fails to be created due to insufficient quota, limit ranges, pod security policy, node selectors,
// etc. or deleted due to kubelet being down or finalizers are failing.
#VirtualMachineInstanceReplicaSetReplicaFailure: #VirtualMachineInstanceReplicaSetConditionType & "ReplicaFailure"

// VirtualMachineInstanceReplicaSetReplicaPaused is added in a replica set when the replica set got paused by the controller.
// After this condition was added, it is safe to remove or add vmis by hand and adjust the replica count by hand.
#VirtualMachineInstanceReplicaSetReplicaPaused: #VirtualMachineInstanceReplicaSetConditionType & "ReplicaPaused"

#DataVolumeTemplateDummyStatus: {
}

#DataVolumeTemplateSpec: {
	metav1.#TypeMeta

	// +kubebuilder:pruning:PreserveUnknownFields
	// +nullable
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// DataVolumeTemplateDummyStatus is here simply for backwards compatibility with
	// a previous API.
	// +nullable
	// +optional
	status?: null | #DataVolumeTemplateDummyStatus @go(Status,*DataVolumeTemplateDummyStatus)
}

#VirtualMachineInstanceTemplateSpec: {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +nullable
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// VirtualMachineInstance Spec contains the VirtualMachineInstance specification.
	spec?: #VirtualMachineInstanceSpec @go(Spec)
}

// VirtualMachineInstanceMigration represents the object tracking a VMI's migration
// to another host in the cluster
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VirtualMachineInstanceMigration: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta                     @go(ObjectMeta)
	spec:      #VirtualMachineInstanceMigrationSpec   @go(Spec)
	status?:   #VirtualMachineInstanceMigrationStatus @go(Status)
}

// VirtualMachineInstanceMigrationList is a list of VirtualMachineMigrations
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceMigrationList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstanceMigration] @go(Items,[]VirtualMachineInstanceMigration)
}

#VirtualMachineInstanceMigrationSpec: {
	// The name of the VMI to perform the migration on. VMI must exist in the migration objects namespace
	vmiName?: string @go(VMIName)
}

// VirtualMachineInstanceMigrationPhaseTransitionTimestamp gives a timestamp in relation to when a phase is set on a vmi
#VirtualMachineInstanceMigrationPhaseTransitionTimestamp: {
	// Phase is the status of the VirtualMachineInstanceMigrationPhase in kubernetes world. It is not the VirtualMachineInstanceMigrationPhase status, but partially correlates to it.
	phase?: #VirtualMachineInstanceMigrationPhase @go(Phase)

	// PhaseTransitionTimestamp is the timestamp of when the phase change occurred
	phaseTransitionTimestamp?: metav1.#Time @go(PhaseTransitionTimestamp)
}

// VirtualMachineInstanceMigration reprents information pertaining to a VMI's migration.
#VirtualMachineInstanceMigrationStatus: {
	phase?: #VirtualMachineInstanceMigrationPhase @go(Phase)
	conditions?: [...#VirtualMachineInstanceMigrationCondition] @go(Conditions,[]VirtualMachineInstanceMigrationCondition)

	// PhaseTransitionTimestamp is the timestamp of when the last phase change occurred
	// +listType=atomic
	// +optional
	phaseTransitionTimestamps?: [...#VirtualMachineInstanceMigrationPhaseTransitionTimestamp] @go(PhaseTransitionTimestamps,[]VirtualMachineInstanceMigrationPhaseTransitionTimestamp)

	// Represents the status of a live migration
	migrationState?: null | #VirtualMachineInstanceMigrationState @go(MigrationState,*VirtualMachineInstanceMigrationState)
}

// VirtualMachineInstanceMigrationPhase is a label for the condition of a VirtualMachineInstanceMigration at the current time.
#VirtualMachineInstanceMigrationPhase: string // #enumVirtualMachineInstanceMigrationPhase

#enumVirtualMachineInstanceMigrationPhase:
	#MigrationPhaseUnset |
	#MigrationPending |
	#MigrationScheduling |
	#MigrationScheduled |
	#MigrationPreparingTarget |
	#MigrationTargetReady |
	#MigrationRunning |
	#MigrationSucceeded |
	#MigrationFailed

#MigrationPhaseUnset: #VirtualMachineInstanceMigrationPhase & ""

// The migration is accepted by the system
#MigrationPending: #VirtualMachineInstanceMigrationPhase & "Pending"

// The migration's target pod is being scheduled
#MigrationScheduling: #VirtualMachineInstanceMigrationPhase & "Scheduling"

// The migration's target pod is running
#MigrationScheduled: #VirtualMachineInstanceMigrationPhase & "Scheduled"

// The migration's target pod is being prepared for migration
#MigrationPreparingTarget: #VirtualMachineInstanceMigrationPhase & "PreparingTarget"

// The migration's target pod is prepared and ready for migration
#MigrationTargetReady: #VirtualMachineInstanceMigrationPhase & "TargetReady"

// The migration is in progress
#MigrationRunning: #VirtualMachineInstanceMigrationPhase & "Running"

// The migration passed
#MigrationSucceeded: #VirtualMachineInstanceMigrationPhase & "Succeeded"

// The migration failed
#MigrationFailed: #VirtualMachineInstanceMigrationPhase & "Failed"

// Deprecated for removal in v2, please use VirtualMachineInstanceType and VirtualMachinePreference instead.
//
// VirtualMachineInstancePreset defines a VMI spec.domain to be applied to all VMIs that match the provided label selector
// More info: https://kubevirt.io/user-guide/virtual_machines/presets/#overrides
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VirtualMachineInstancePreset: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// VirtualMachineInstance Spec contains the VirtualMachineInstance specification.
	spec?: #VirtualMachineInstancePresetSpec @go(Spec)
}

// VirtualMachineInstancePresetList is a list of VirtualMachinePresets
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstancePresetList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstancePreset] @go(Items,[]VirtualMachineInstancePreset)
}

#VirtualMachineInstancePresetSpec: {
	// Selector is a label query over a set of VMIs.
	// Required.
	selector: metav1.#LabelSelector @go(Selector)

	// Domain is the same object type as contained in VirtualMachineInstanceSpec
	domain?: null | #DomainSpec @go(Domain,*DomainSpec)
}

// VirtualMachine handles the VirtualMachines that are not running
// or are in a stopped state
// The VirtualMachine contains the template to create the
// VirtualMachineInstance. It also mirrors the running state of the created
// VirtualMachineInstance in its status.
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VirtualMachine: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec contains the specification of VirtualMachineInstance created
	spec: #VirtualMachineSpec @go(Spec)

	// Status holds the current state of the controller and brief information
	// about its associated VirtualMachineInstance
	status?: #VirtualMachineStatus @go(Status)
}

// VirtualMachineList is a list of virtualmachines
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachine] @go(Items,[]VirtualMachine)
}

// VirtualMachineRunStrategy is a label for the requested VirtualMachineInstance Running State at the current time.
#VirtualMachineRunStrategy: string // #enumVirtualMachineRunStrategy

#enumVirtualMachineRunStrategy:
	#RunStrategyUnknown |
	#RunStrategyAlways |
	#RunStrategyHalted |
	#RunStrategyManual |
	#RunStrategyRerunOnFailure |
	#RunStrategyOnce

// Placeholder. Not a valid RunStrategy.
#RunStrategyUnknown: #VirtualMachineRunStrategy & ""

// VMI should always be running.
#RunStrategyAlways: #VirtualMachineRunStrategy & "Always"

// VMI should never be running.
#RunStrategyHalted: #VirtualMachineRunStrategy & "Halted"

// VMI can be started/stopped using API endpoints.
#RunStrategyManual: #VirtualMachineRunStrategy & "Manual"

// VMI will initially be running--and restarted if a failure occurs.
// It will not be restarted upon successful completion.
#RunStrategyRerunOnFailure: #VirtualMachineRunStrategy & "RerunOnFailure"

// VMI will run once and not be restarted upon completion regardless
// if the completion is of phase Failure or Success
#RunStrategyOnce: #VirtualMachineRunStrategy & "Once"

// VirtualMachineSpec describes how the proper VirtualMachine
// should look like
#VirtualMachineSpec: {
	// Running controls whether the associatied VirtualMachineInstance is created or not
	// Mutually exclusive with RunStrategy
	running?: null | bool @go(Running,*bool)

	// Running state indicates the requested running state of the VirtualMachineInstance
	// mutually exclusive with Running
	runStrategy?: null | #VirtualMachineRunStrategy @go(RunStrategy,*VirtualMachineRunStrategy)

	// InstancetypeMatcher references a instancetype that is used to fill fields in Template
	instancetype?: null | #InstancetypeMatcher @go(Instancetype,*InstancetypeMatcher)

	// PreferenceMatcher references a set of preference that is used to fill fields in Template
	preference?: null | #PreferenceMatcher @go(Preference,*PreferenceMatcher)

	// Template is the direct specification of VirtualMachineInstance
	template?: null | #VirtualMachineInstanceTemplateSpec @go(Template,*VirtualMachineInstanceTemplateSpec)

	// dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference.
	// DataVolumes in this list are dynamically created for the VirtualMachine and are tied to the VirtualMachine's life-cycle.
	dataVolumeTemplates?: [...#DataVolumeTemplateSpec] @go(DataVolumeTemplates,[]DataVolumeTemplateSpec)
}

// StateChangeRequestType represents the existing state change requests that are possible
#StateChangeRequestAction: string // #enumStateChangeRequestAction

#enumStateChangeRequestAction:
	#StartRequest |
	#StopRequest

#StartRequest: #StateChangeRequestAction & "Start"
#StopRequest:  #StateChangeRequestAction & "Stop"

// VirtualMachinePrintableStatus is a human readable, high-level representation of the status of the virtual machine.
#VirtualMachinePrintableStatus: string // #enumVirtualMachinePrintableStatus

#enumVirtualMachinePrintableStatus:
	#VirtualMachineStatusStopped |
	#VirtualMachineStatusProvisioning |
	#VirtualMachineStatusStarting |
	#VirtualMachineStatusRunning |
	#VirtualMachineStatusPaused |
	#VirtualMachineStatusStopping |
	#VirtualMachineStatusTerminating |
	#VirtualMachineStatusCrashLoopBackOff |
	#VirtualMachineStatusMigrating |
	#VirtualMachineStatusUnknown |
	#VirtualMachineStatusUnschedulable |
	#VirtualMachineStatusErrImagePull |
	#VirtualMachineStatusImagePullBackOff |
	#VirtualMachineStatusPvcNotFound |
	#VirtualMachineStatusDataVolumeError |
	#VirtualMachineStatusWaitingForVolumeBinding

// VirtualMachineStatusStopped indicates that the virtual machine is currently stopped and isn't expected to start.
#VirtualMachineStatusStopped: #VirtualMachinePrintableStatus & "Stopped"

// VirtualMachineStatusProvisioning indicates that cluster resources associated with the virtual machine
// (e.g., DataVolumes) are being provisioned and prepared.
#VirtualMachineStatusProvisioning: #VirtualMachinePrintableStatus & "Provisioning"

// VirtualMachineStatusStarting indicates that the virtual machine is being prepared for running.
#VirtualMachineStatusStarting: #VirtualMachinePrintableStatus & "Starting"

// VirtualMachineStatusRunning indicates that the virtual machine is running.
#VirtualMachineStatusRunning: #VirtualMachinePrintableStatus & "Running"

// VirtualMachineStatusPaused indicates that the virtual machine is paused.
#VirtualMachineStatusPaused: #VirtualMachinePrintableStatus & "Paused"

// VirtualMachineStatusStopping indicates that the virtual machine is in the process of being stopped.
#VirtualMachineStatusStopping: #VirtualMachinePrintableStatus & "Stopping"

// VirtualMachineStatusTerminating indicates that the virtual machine is in the process of deletion,
// as well as its associated resources (VirtualMachineInstance, DataVolumes, …).
#VirtualMachineStatusTerminating: #VirtualMachinePrintableStatus & "Terminating"

// VirtualMachineStatusCrashLoopBackOff indicates that the virtual machine is currently in a crash loop waiting to be retried.
#VirtualMachineStatusCrashLoopBackOff: #VirtualMachinePrintableStatus & "CrashLoopBackOff"

// VirtualMachineStatusMigrating indicates that the virtual machine is in the process of being migrated
// to another host.
#VirtualMachineStatusMigrating: #VirtualMachinePrintableStatus & "Migrating"

// VirtualMachineStatusUnknown indicates that the state of the virtual machine could not be obtained,
// typically due to an error in communicating with the host on which it's running.
#VirtualMachineStatusUnknown: #VirtualMachinePrintableStatus & "Unknown"

// VirtualMachineStatusUnschedulable indicates that an error has occurred while scheduling the virtual machine,
// e.g. due to unsatisfiable resource requests or unsatisfiable scheduling constraints.
#VirtualMachineStatusUnschedulable: #VirtualMachinePrintableStatus & "ErrorUnschedulable"

// VirtualMachineStatusErrImagePull indicates that an error has occured while pulling an image for
// a containerDisk VM volume.
#VirtualMachineStatusErrImagePull: #VirtualMachinePrintableStatus & "ErrImagePull"

// VirtualMachineStatusImagePullBackOff indicates that an error has occured while pulling an image for
// a containerDisk VM volume, and that kubelet is backing off before retrying.
#VirtualMachineStatusImagePullBackOff: #VirtualMachinePrintableStatus & "ImagePullBackOff"

// VirtualMachineStatusPvcNotFound indicates that the virtual machine references a PVC volume which doesn't exist.
#VirtualMachineStatusPvcNotFound: #VirtualMachinePrintableStatus & "ErrorPvcNotFound"

// VirtualMachineStatusDataVolumeError indicates that an error has been reported by one of the DataVolumes
// referenced by the virtual machines.
#VirtualMachineStatusDataVolumeError: #VirtualMachinePrintableStatus & "DataVolumeError"

// VirtualMachineStatusWaitingForVolumeBinding indicates that some PersistentVolumeClaims backing
// the virtual machine volume are still not bound.
#VirtualMachineStatusWaitingForVolumeBinding: #VirtualMachinePrintableStatus & "WaitingForVolumeBinding"

// VirtualMachineStartFailure tracks VMIs which failed to transition successfully
// to running using the VM status
#VirtualMachineStartFailure: {
	consecutiveFailCount?: int                 @go(ConsecutiveFailCount)
	lastFailedVMIUID?:     types.#UID          @go(LastFailedVMIUID)
	retryAfterTimestamp?:  null | metav1.#Time @go(RetryAfterTimestamp,*metav1.Time)
}

// VirtualMachineStatus represents the status returned by the
// controller to describe how the VirtualMachine is doing
#VirtualMachineStatus: {
	// SnapshotInProgress is the name of the VirtualMachineSnapshot currently executing
	snapshotInProgress?: null | string @go(SnapshotInProgress,*string)

	// RestoreInProgress is the name of the VirtualMachineRestore currently executing
	restoreInProgress?: null | string @go(RestoreInProgress,*string)

	// Created indicates if the virtual machine is created in the cluster
	created?: bool @go(Created)

	// Ready indicates if the virtual machine is running and ready
	ready?: bool @go(Ready)

	// PrintableStatus is a human readable, high-level representation of the status of the virtual machine
	printableStatus?: #VirtualMachinePrintableStatus @go(PrintableStatus)

	// Hold the state information of the VirtualMachine and its VirtualMachineInstance
	conditions?: [...#VirtualMachineCondition] @go(Conditions,[]VirtualMachineCondition)

	// StateChangeRequests indicates a list of actions that should be taken on a VMI
	// e.g. stop a specific VMI then start a new one.
	stateChangeRequests?: [...#VirtualMachineStateChangeRequest] @go(StateChangeRequests,[]VirtualMachineStateChangeRequest)

	// VolumeRequests indicates a list of volumes add or remove from the VMI template and
	// hotplug on an active running VMI.
	// +listType=atomic
	volumeRequests?: [...#VirtualMachineVolumeRequest] @go(VolumeRequests,[]VirtualMachineVolumeRequest)

	// VolumeSnapshotStatuses indicates a list of statuses whether snapshotting is
	// supported by each volume.
	volumeSnapshotStatuses?: [...#VolumeSnapshotStatus] @go(VolumeSnapshotStatuses,[]VolumeSnapshotStatus)

	// StartFailure tracks consecutive VMI startup failures for the purposes of
	// crash loop backoffs
	// +nullable
	// +optional
	startFailure?: null | #VirtualMachineStartFailure @go(StartFailure,*VirtualMachineStartFailure)

	// MemoryDumpRequest tracks memory dump request phase and info of getting a memory
	// dump to the given pvc
	// +nullable
	// +optional
	memoryDumpRequest?: null | #VirtualMachineMemoryDumpRequest @go(MemoryDumpRequest,*VirtualMachineMemoryDumpRequest)
}

#VolumeSnapshotStatus: {
	// Volume name
	name: string @go(Name)

	// True if the volume supports snapshotting
	enabled: bool @go(Enabled)

	// Empty if snapshotting is enabled, contains reason otherwise
	reason?: string @go(Reason)
}

#VirtualMachineVolumeRequest: {
	// AddVolumeOptions when set indicates a volume should be added. The details
	// within this field specify how to add the volume
	addVolumeOptions?: null | #AddVolumeOptions @go(AddVolumeOptions,*AddVolumeOptions)

	// RemoveVolumeOptions when set indicates a volume should be removed. The details
	// within this field specify how to add the volume
	removeVolumeOptions?: null | #RemoveVolumeOptions @go(RemoveVolumeOptions,*RemoveVolumeOptions)
}

#VirtualMachineStateChangeRequest: {
	// Indicates the type of action that is requested. e.g. Start or Stop
	action: #StateChangeRequestAction @go(Action)

	// Provides additional data in order to perform the Action
	data?: {[string]: string} @go(Data,map[string]string)

	// Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable
	uid?: null | types.#UID @go(UID,*types.UID) @protobuf(5,bytes,opt,casttype=k8s.io/kubernetes/pkg/types.UID)
}

// VirtualMachineCondition represents the state of VirtualMachine
#VirtualMachineCondition: {
	type:   #VirtualMachineConditionType @go(Type)
	status: k8sv1.#ConditionStatus       @go(Status)

	// +nullable
	lastProbeTime?: metav1.#Time @go(LastProbeTime)

	// +nullable
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
	reason?:             string       @go(Reason)
	message?:            string       @go(Message)
}

#VirtualMachineConditionType: string // #enumVirtualMachineConditionType

#enumVirtualMachineConditionType:
	#VirtualMachineFailure |
	#VirtualMachineReady |
	#VirtualMachinePaused

// VirtualMachineFailure is added in a virtual machine when its vmi
// fails to be created due to insufficient quota, limit ranges, pod security policy, node selectors,
// etc. or deleted due to kubelet being down or finalizers are failing.
#VirtualMachineFailure: #VirtualMachineConditionType & "Failure"

// VirtualMachineReady is copied to the virtual machine from its vmi
#VirtualMachineReady: #VirtualMachineConditionType & "Ready"

// VirtualMachinePaused is added in a virtual machine when its vmi
// signals with its own condition that it is paused.
#VirtualMachinePaused: #VirtualMachineConditionType & "Paused"

#HostDiskType: string // #enumHostDiskType

#enumHostDiskType:
	#HostDiskExistsOrCreate |
	#HostDiskExists

// if disk does not exist at the given path,
// a disk image will be created there
#HostDiskExistsOrCreate: #HostDiskType & "DiskOrCreate"

// a disk image must exist at given disk path
#HostDiskExists: #HostDiskType & "Disk"

#NetworkInterfaceType: string // #enumNetworkInterfaceType

#enumNetworkInterfaceType:
	#BridgeInterface |
	#SlirpInterface |
	#MasqueradeInterface |
	#PasstInterface

// Virtual machine instance bride interface
#BridgeInterface: #NetworkInterfaceType & "bridge"

// Virtual machine instance slirp interface
#SlirpInterface: #NetworkInterfaceType & "slirp"

// Virtual machine instance masquerade interface
#MasqueradeInterface: #NetworkInterfaceType & "masquerade"

// Virtual machine instance passt interface
#PasstInterface: #NetworkInterfaceType & "passt"

#DriverCache: string // #enumDriverCache

#enumDriverCache:
	#CacheNone |
	#CacheWriteThrough |
	#CacheWriteBack

#DriverIO: string // #enumDriverIO

#enumDriverIO:
	#IOThreads |
	#IONative |
	#IODefault

// CacheNone - I/O from the guest is not cached on the host, but may be kept in a writeback disk cache.
#CacheNone: #DriverCache & "none"

// CacheWriteThrough - I/O from the guest is cached on the host but written through to the physical medium.
#CacheWriteThrough: #DriverCache & "writethrough"

// CacheWriteBack - I/O from the guest is cached on the host.
#CacheWriteBack: #DriverCache & "writeback"

// IOThreads - User mode based threads with a shared lock that perform I/O tasks. Can impact performance but offers
// more predictable behaviour. This method is also takes fewer CPU cycles to submit I/O requests.
#IOThreads: #DriverIO & "threads"

// IONative - Kernel native I/O tasks (AIO) offer a better performance but can block the VM if the file is not fully
// allocated so this method recommended only when the backing file/disk/etc is fully preallocated.
#IONative: #DriverIO & "native"

// IODefault - Fallback to the default value from the kernel. With recent Kernel versions (for example RHEL-7) the
// default is AIO.
#IODefault: #DriverIO & "default"

// Handler defines a specific action that should be taken
// TODO: pass structured data to these actions, and document that data here.
#Handler: {
	// One and only one of the following should be specified.
	// Exec specifies the action to take, it will be executed on the guest through the qemu-guest-agent.
	// If the guest agent is not available, this probe will fail.
	// +optional
	exec?: null | k8sv1.#ExecAction @go(Exec,*k8sv1.ExecAction) @protobuf(1,bytes,opt)

	// GuestAgentPing contacts the qemu-guest-agent for availability checks.
	// +optional
	guestAgentPing?: null | #GuestAgentPing @go(GuestAgentPing,*GuestAgentPing)

	// HTTPGet specifies the http request to perform.
	// +optional
	httpGet?: null | k8sv1.#HTTPGetAction @go(HTTPGet,*k8sv1.HTTPGetAction)

	// TCPSocket specifies an action involving a TCP port.
	// TCP hooks not yet supported
	// TODO: implement a realistic TCP lifecycle hook
	// +optional
	tcpSocket?: null | k8sv1.#TCPSocketAction @go(TCPSocket,*k8sv1.TCPSocketAction)
}

// Probe describes a health check to be performed against a VirtualMachineInstance to determine whether it is
// alive or ready to receive traffic.
#Probe: {
	#Handler

	// Number of seconds after the VirtualMachineInstance has started before liveness probes are initiated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	initialDelaySeconds?: int32 @go(InitialDelaySeconds)

	// Number of seconds after which the probe times out.
	// For exec probes the timeout fails the probe but does not terminate the command running on the guest.
	// This means a blocking command can result in an increasing load on the guest.
	// A small buffer will be added to the resulting workload exec probe to compensate for delays
	// caused by the qemu guest exec mechanism.
	// Defaults to 1 second. Minimum value is 1.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	timeoutSeconds?: int32 @go(TimeoutSeconds)

	// How often (in seconds) to perform the probe.
	// Default to 10 seconds. Minimum value is 1.
	// +optional
	periodSeconds?: int32 @go(PeriodSeconds)

	// Minimum consecutive successes for the probe to be considered successful after having failed.
	// Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	// +optional
	successThreshold?: int32 @go(SuccessThreshold)

	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	// Defaults to 3. Minimum value is 1.
	// +optional
	failureThreshold?: int32 @go(FailureThreshold)
}

// KubeVirt represents the object deploying all KubeVirt resources
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#KubeVirt: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec:      #KubeVirtSpec      @go(Spec)
	status?:   #KubeVirtStatus    @go(Status)
}

// KubeVirtList is a list of KubeVirts
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#KubeVirtList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#KubeVirt] @go(Items,[]KubeVirt)
}

#KubeVirtSelfSignConfiguration: {
	// Deprecated. Use CA.Duration instead
	caRotateInterval?: null | metav1.#Duration @go(CARotateInterval,*metav1.Duration)

	// Deprecated. Use Server.Duration instead
	certRotateInterval?: null | metav1.#Duration @go(CertRotateInterval,*metav1.Duration)

	// Deprecated. Use CA.Duration and CA.RenewBefore instead
	caOverlapInterval?: null | metav1.#Duration @go(CAOverlapInterval,*metav1.Duration)

	// CA configuration
	// CA certs are kept in the CA bundle as long as they are valid
	ca?: null | #CertConfig @go(CA,*CertConfig)

	// Server configuration
	// Certs are rotated and discarded
	server?: null | #CertConfig @go(Server,*CertConfig)
}

// CertConfig contains the tunables for TLS certificates
#CertConfig: {
	// The requested 'duration' (i.e. lifetime) of the Certificate.
	duration?: null | metav1.#Duration @go(Duration,*metav1.Duration)

	// The amount of time before the currently issued certificate's "notAfter"
	// time that we will begin to attempt to renew the certificate.
	renewBefore?: null | metav1.#Duration @go(RenewBefore,*metav1.Duration)
}

#KubeVirtCertificateRotateStrategy: {
	selfSigned?: null | #KubeVirtSelfSignConfiguration @go(SelfSigned,*KubeVirtSelfSignConfiguration)
}

#WorkloadUpdateMethod: string // #enumWorkloadUpdateMethod

#enumWorkloadUpdateMethod:
	#WorkloadUpdateMethodLiveMigrate |
	#WorkloadUpdateMethodEvict

// WorkloadUpdateMethodLiveMigrate allows VMIs which are capable of being
// migrated to automatically migrate during automated workload updates.
#WorkloadUpdateMethodLiveMigrate: #WorkloadUpdateMethod & "LiveMigrate"

// WorkloadUpdateMethodEvict results in a VMI's pod being evicted. Unless the
// pod has a pod disruption budget allocated, the eviction will usually result in
// the VMI being shutdown.
// Depending on whether a VMI is backed by a VM or not, this will either result
// in a restart of the VM by rescheduling a new VMI, or the shutdown via eviction
// of a standalone VMI object.
#WorkloadUpdateMethodEvict: #WorkloadUpdateMethod & "Evict"

// KubeVirtWorkloadUpdateStrategy defines options related to updating a KubeVirt install
#KubeVirtWorkloadUpdateStrategy: {
	// WorkloadUpdateMethods defines the methods that can be used to disrupt workloads
	// during automated workload updates.
	// When multiple methods are present, the least disruptive method takes
	// precedence over more disruptive methods. For example if both LiveMigrate and Shutdown
	// methods are listed, only VMs which are not live migratable will be restarted/shutdown
	//
	// An empty list defaults to no automated workload updating
	//
	// +listType=atomic
	// +optional
	workloadUpdateMethods?: [...#WorkloadUpdateMethod] @go(WorkloadUpdateMethods,[]WorkloadUpdateMethod)

	// BatchEvictionSize Represents the number of VMIs that can be forced updated per
	// the BatchShutdownInteral interval
	//
	// Defaults to 10
	//
	// +optional
	batchEvictionSize?: null | int @go(BatchEvictionSize,*int)

	// BatchEvictionInterval Represents the interval to wait before issuing the next
	// batch of shutdowns
	//
	// Defaults to 1 minute
	//
	// +optional
	batchEvictionInterval?: null | metav1.#Duration @go(BatchEvictionInterval,*metav1.Duration)
}

#KubeVirtSpec: {
	// The image tag to use for the continer images installed.
	// Defaults to the same tag as the operator's container image.
	imageTag?: string @go(ImageTag)

	// The image registry to pull the container images from
	// Defaults to the same registry the operator's container image is pulled from.
	imageRegistry?: string @go(ImageRegistry)

	// The ImagePullPolicy to use.
	imagePullPolicy?: k8sv1.#PullPolicy @go(ImagePullPolicy)

	// The imagePullSecrets to pull the container images from
	// Defaults to none
	// +listType=atomic
	imagePullSecrets?: [...k8sv1.#LocalObjectReference] @go(ImagePullSecrets,[]k8sv1.LocalObjectReference)

	// The namespace Prometheus is deployed in
	// Defaults to openshift-monitor
	monitorNamespace?: string @go(MonitorNamespace)

	// The namespace the service monitor will be deployed
	//  When ServiceMonitorNamespace is set, then we'll install the service monitor object in that namespace
	// otherwise we will use the monitoring namespace.
	serviceMonitorNamespace?: string @go(ServiceMonitorNamespace)

	// The name of the Prometheus service account that needs read-access to KubeVirt endpoints
	// Defaults to prometheus-k8s
	monitorAccount?: string @go(MonitorAccount)

	// WorkloadUpdateStrategy defines at the cluster level how to handle
	// automated workload updates
	workloadUpdateStrategy?: #KubeVirtWorkloadUpdateStrategy @go(WorkloadUpdateStrategy)

	// Specifies if kubevirt can be deleted if workloads are still present.
	// This is mainly a precaution to avoid accidental data loss
	uninstallStrategy?:         #KubeVirtUninstallStrategy         @go(UninstallStrategy)
	certificateRotateStrategy?: #KubeVirtCertificateRotateStrategy @go(CertificateRotationStrategy)

	// Designate the apps.kubevirt.io/version label for KubeVirt components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductVersion is not specified, KubeVirt's version will be used.
	productVersion?: string @go(ProductVersion)

	// Designate the apps.kubevirt.io/part-of label for KubeVirt components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductName is not specified, the part-of label will be omitted.
	productName?: string @go(ProductName)

	// Designate the apps.kubevirt.io/component label for KubeVirt components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductComponent is not specified, the component label default value is kubevirt.
	productComponent?: string @go(ProductComponent)

	// holds kubevirt configurations.
	// same as the virt-configMap
	configuration?: #KubeVirtConfiguration @go(Configuration)

	// selectors and tolerations that should apply to KubeVirt infrastructure components
	// +optional
	infra?: null | #ComponentConfig @go(Infra,*ComponentConfig)

	// selectors and tolerations that should apply to KubeVirt workloads
	// +optional
	workloads?:           null | #ComponentConfig @go(Workloads,*ComponentConfig)
	customizeComponents?: #CustomizeComponents    @go(CustomizeComponents)
}

#CustomizeComponents: {
	// +listType=atomic
	patches?: [...#CustomizeComponentsPatch] @go(Patches,[]CustomizeComponentsPatch)

	// Configure the value used for deployment and daemonset resources
	flags?: null | #Flags @go(Flags,*Flags)
}

// Flags will create a patch that will replace all flags for the container's
// command field. The only flags that will be used are those define. There are no
// guarantees around forward/backward compatibility.  If set incorrectly this will
// cause the resource when rolled out to error until flags are updated.
#Flags: {
	api?: {[string]: string} @go(API,map[string]string)
	controller?: {[string]: string} @go(Controller,map[string]string)
	handler?: {[string]: string} @go(Handler,map[string]string)
}

#CustomizeComponentsPatch: {
	// +kubebuilder:validation:MinLength=1
	resourceName: string @go(ResourceName)

	// +kubebuilder:validation:MinLength=1
	resourceType: string     @go(ResourceType)
	patch:        string     @go(Patch)
	type:         #PatchType @go(Type)
}

#PatchType: string // #enumPatchType

#enumPatchType:
	#JSONPatchType |
	#MergePatchType |
	#StrategicMergePatchType

#JSONPatchType:           #PatchType & "json"
#MergePatchType:          #PatchType & "merge"
#StrategicMergePatchType: #PatchType & "strategic"

#KubeVirtUninstallStrategy: string // #enumKubeVirtUninstallStrategy

#enumKubeVirtUninstallStrategy:
	#KubeVirtUninstallStrategyRemoveWorkloads |
	#KubeVirtUninstallStrategyBlockUninstallIfWorkloadsExist

#KubeVirtUninstallStrategyRemoveWorkloads:                #KubeVirtUninstallStrategy & "RemoveWorkloads"
#KubeVirtUninstallStrategyBlockUninstallIfWorkloadsExist: #KubeVirtUninstallStrategy & "BlockUninstallIfWorkloadsExist"

// GenerationStatus keeps track of the generation for a given resource so that decisions about forced updates can be made.
#GenerationStatus: {
	// group is the group of the thing you're tracking
	group: string @go(Group)

	// resource is the resource type of the thing you're tracking
	resource: string @go(Resource)

	// namespace is where the thing you're tracking is
	// +optional
	namespace?: string @go(Namespace)

	// name is the name of the thing you're tracking
	name: string @go(Name)

	// lastGeneration is the last generation of the workload controller involved
	lastGeneration: int64 @go(LastGeneration)

	// hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps
	// +optional
	hash?: string @go(Hash)
}

// KubeVirtStatus represents information pertaining to a KubeVirt deployment.
#KubeVirtStatus: {
	phase?: #KubeVirtPhase @go(Phase)
	conditions?: [...#KubeVirtCondition] @go(Conditions,[]KubeVirtCondition)
	operatorVersion?:                         string       @go(OperatorVersion)
	targetKubeVirtRegistry?:                  string       @go(TargetKubeVirtRegistry)
	targetKubeVirtVersion?:                   string       @go(TargetKubeVirtVersion)
	targetDeploymentConfig?:                  string       @go(TargetDeploymentConfig)
	targetDeploymentID?:                      string       @go(TargetDeploymentID)
	observedKubeVirtRegistry?:                string       @go(ObservedKubeVirtRegistry)
	observedKubeVirtVersion?:                 string       @go(ObservedKubeVirtVersion)
	observedDeploymentConfig?:                string       @go(ObservedDeploymentConfig)
	observedDeploymentID?:                    string       @go(ObservedDeploymentID)
	outdatedVirtualMachineInstanceWorkloads?: null | int   @go(OutdatedVirtualMachineInstanceWorkloads,*int)
	observedGeneration?:                      null | int64 @go(ObservedGeneration,*int64)

	// +listType=atomic
	generations?: [...#GenerationStatus] @go(Generations,[]GenerationStatus)
}

// KubeVirtPhase is a label for the phase of a KubeVirt deployment at the current time.
#KubeVirtPhase: string // #enumKubeVirtPhase

#enumKubeVirtPhase:
	#KubeVirtPhaseDeploying |
	#KubeVirtPhaseDeployed |
	#KubeVirtPhaseDeleting |
	#KubeVirtPhaseDeleted

// The deployment is processing
#KubeVirtPhaseDeploying: #KubeVirtPhase & "Deploying"

// The deployment succeeded
#KubeVirtPhaseDeployed: #KubeVirtPhase & "Deployed"

// The deletion is processing
#KubeVirtPhaseDeleting: #KubeVirtPhase & "Deleting"

// The deletion succeeeded
#KubeVirtPhaseDeleted: #KubeVirtPhase & "Deleted"

// KubeVirtCondition represents a condition of a KubeVirt deployment
#KubeVirtCondition: {
	type:   #KubeVirtConditionType @go(Type)
	status: k8sv1.#ConditionStatus @go(Status)

	// +optional
	// +nullable
	lastProbeTime?: metav1.#Time @go(LastProbeTime)

	// +optional
	// +nullable
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
	reason?:             string       @go(Reason)
	message?:            string       @go(Message)
}

#KubeVirtConditionType: string // #enumKubeVirtConditionType

#enumKubeVirtConditionType:
	#KubeVirtConditionSynchronized |
	#KubeVirtConditionCreated |
	#KubeVirtConditionAvailable |
	#KubeVirtConditionProgressing |
	#KubeVirtConditionDegraded

// Whether the deployment or deletion was successful (only used if false)
#KubeVirtConditionSynchronized: #KubeVirtConditionType & "Synchronized"

// Whether all resources were created and up-to-date
#KubeVirtConditionCreated: #KubeVirtConditionType & "Created"

// Conditions for HCO, see https://github.com/kubevirt/hyperconverged-cluster-operator/blob/master/docs/conditions.md
// Whether KubeVirt is functional and available in the cluster.
#KubeVirtConditionAvailable: #KubeVirtConditionType & "Available"

// Whether the operator is actively making changes to KubeVirt
#KubeVirtConditionProgressing: #KubeVirtConditionType & "Progressing"

// Whether KubeVirt is not functioning completely
#KubeVirtConditionDegraded: #KubeVirtConditionType & "Degraded"

#EvictionStrategyNone:        #EvictionStrategy & "None"
#EvictionStrategyLiveMigrate: #EvictionStrategy & "LiveMigrate"
#EvictionStrategyExternal:    #EvictionStrategy & "External"

// RestartOptions may be provided when deleting an API object.
#RestartOptions: {
	metav1.#TypeMeta

	// The duration in seconds before the object should be force-restarted. Value must be non-negative integer.
	// The value zero indicates, restart immediately. If this value is nil, the default grace period for deletion of the corresponding VMI for the
	// specified type will be used to determine on how much time to give the VMI to restart.
	// Defaults to a per object value if not specified. zero means restart immediately.
	// Allowed Values: nil and 0
	// +optional
	gracePeriodSeconds?: null | int64 @go(GracePeriodSeconds,*int64) @protobuf(1,varint,opt)

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(2,bytes,rep)
}

// StartOptions may be provided on start request.
#StartOptions: {
	metav1.#TypeMeta

	// Indicates that VM will be started in paused state.
	// +optional
	paused?: bool @go(Paused) @protobuf(7,varint,opt)

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(5,bytes,rep)
}

// PauseOptions may be provided on pause request.
#PauseOptions: {
	metav1.#TypeMeta

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(1,bytes,rep)
}

// UnpauseOptions may be provided on unpause request.
#UnpauseOptions: {
	metav1.#TypeMeta

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(1,bytes,rep)
}

#StartRequestDataPausedKey:  "paused"
#StartRequestDataPausedTrue: "true"

// StopOptions may be provided when deleting an API object.
#StopOptions: {
	metav1.#TypeMeta

	// this updates the VMIs terminationGracePeriodSeconds during shutdown
	// +optional
	gracePeriod?: null | int64 @go(GracePeriod,*int64) @protobuf(1,varint,opt)

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(2,bytes,rep)
}

// MigrateOptions may be provided on migrate request.
#MigrateOptions: {
	metav1.#TypeMeta

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string) @protobuf(1,bytes,rep)
}

// VirtualMachineInstanceGuestAgentInfo represents information from the installed guest agent
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceGuestAgentInfo: {
	metav1.#TypeMeta

	// GAVersion is a version of currently installed guest agent
	guestAgentVersion?: string @go(GAVersion)

	// Return command list the guest agent supports
	// +listType=atomic
	supportedCommands?: [...#GuestAgentCommandInfo] @go(SupportedCommands,[]GuestAgentCommandInfo)

	// Hostname represents FQDN of a guest
	hostname?: string @go(Hostname)

	// OS contains the guest operating system information
	os?: #VirtualMachineInstanceGuestOSInfo @go(OS)

	// Timezone is guest os current timezone
	timezone?: string @go(Timezone)

	// UserList is a list of active guest OS users
	userList?: [...#VirtualMachineInstanceGuestOSUser] @go(UserList,[]VirtualMachineInstanceGuestOSUser)

	// FSInfo is a guest os filesystem information containing the disk mapping and disk mounts with usage
	fsInfo?: #VirtualMachineInstanceFileSystemInfo @go(FSInfo)

	// FSFreezeStatus is the state of the fs of the guest
	// it can be either frozen or thawed
	fsFreezeStatus?: string @go(FSFreezeStatus)
}

// List of commands that QEMU guest agent supports
#GuestAgentCommandInfo: {
	name:     string @go(Name)
	enabled?: bool   @go(Enabled)
}

// VirtualMachineInstanceGuestOSUserList comprises the list of all active users on guest machine
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceGuestOSUserList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstanceGuestOSUser] @go(Items,[]VirtualMachineInstanceGuestOSUser)
}

// VirtualMachineGuestOSUser is the single user of the guest os
#VirtualMachineInstanceGuestOSUser: {
	userName:   string  @go(UserName)
	domain?:    string  @go(Domain)
	loginTime?: float64 @go(LoginTime)
}

// VirtualMachineInstanceFileSystemInfo represents information regarding single guest os filesystem
#VirtualMachineInstanceFileSystemInfo: {
	disks: [...#VirtualMachineInstanceFileSystem] @go(Filesystems,[]VirtualMachineInstanceFileSystem)
}

// VirtualMachineInstanceFileSystemList comprises the list of all filesystems on guest machine
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VirtualMachineInstanceFileSystemList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VirtualMachineInstanceFileSystem] @go(Items,[]VirtualMachineInstanceFileSystem)
}

// VirtualMachineInstanceFileSystem represents guest os disk
#VirtualMachineInstanceFileSystem: {
	diskName:       string @go(DiskName)
	mountPoint:     string @go(MountPoint)
	fileSystemType: string @go(FileSystemType)
	usedBytes:      int    @go(UsedBytes)
	totalBytes:     int    @go(TotalBytes)
}

// FreezeUnfreezeTimeout represent the time unfreeze will be triggered if guest was not unfrozen by unfreeze command
#FreezeUnfreezeTimeout: {
	unfreezeTimeout?: null | metav1.#Duration @go(UnfreezeTimeout,*metav1.Duration)
}

// VirtualMachineMemoryDumpRequest represent the memory dump request phase and info
#VirtualMachineMemoryDumpRequest: {
	// ClaimName is the name of the pvc that will contain the memory dump
	claimName: string @go(ClaimName)

	// Phase represents the memory dump phase
	phase: #MemoryDumpPhase @go(Phase)

	// Remove represents request of dissociating the memory dump pvc
	// +optional
	remove?: bool @go(Remove)

	// StartTimestamp represents the time the memory dump started
	// +optional
	startTimestamp?: null | metav1.#Time @go(StartTimestamp,*metav1.Time)

	// EndTimestamp represents the time the memory dump was completed
	// +optional
	endTimestamp?: null | metav1.#Time @go(EndTimestamp,*metav1.Time)

	// FileName represents the name of the output file
	// +optional
	fileName?: null | string @go(FileName,*string)

	// Message is a detailed message about failure of the memory dump
	// +optional
	message?: string @go(Message)
}

#MemoryDumpPhase: string // #enumMemoryDumpPhase

#enumMemoryDumpPhase:
	#MemoryDumpAssociating |
	#MemoryDumpInProgress |
	#MemoryDumpUnmounting |
	#MemoryDumpCompleted |
	#MemoryDumpDissociating |
	#MemoryDumpFailed

// The memorydump is during pvc Associating
#MemoryDumpAssociating: #MemoryDumpPhase & "Associating"

// The memorydump is in progress
#MemoryDumpInProgress: #MemoryDumpPhase & "InProgress"

// The memorydump is being unmounted
#MemoryDumpUnmounting: #MemoryDumpPhase & "Unmounting"

// The memorydump is completed
#MemoryDumpCompleted: #MemoryDumpPhase & "Completed"

// The memorydump is being unbound
#MemoryDumpDissociating: #MemoryDumpPhase & "Dissociating"

// The memorydump failed
#MemoryDumpFailed: #MemoryDumpPhase & "Failed"

// AddVolumeOptions is provided when dynamically hot plugging a volume and disk
#AddVolumeOptions: {
	// Name represents the name that will be used to map the
	// disk to the corresponding volume. This overrides any name
	// set inside the Disk struct itself.
	name: string @go(Name)

	// Disk represents the hotplug disk that will be plugged into the running VMI
	disk?: null | #Disk @go(Disk,*Disk)

	// VolumeSource represents the source of the volume to map to the disk.
	volumeSource?: null | #HotplugVolumeSource @go(VolumeSource,*HotplugVolumeSource)

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string)
}

#ScreenshotOptions: {
	moveCursor: bool @go(MoveCursor)
}

#VSOCKOptions: {
	targetPort: uint32      @go(TargetPort)
	useTLS?:    null | bool @go(UseTLS,*bool)
}

// RemoveVolumeOptions is provided when dynamically hot unplugging volume and disk
#RemoveVolumeOptions: {
	// Name represents the name that maps to both the disk and volume that
	// should be removed
	name: string @go(Name)

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	// +listType=atomic
	dryRun?: [...string] @go(DryRun,[]string)
}

#TokenBucketRateLimiter: {
	// QPS indicates the maximum QPS to the apiserver from this client.
	// If it's zero, the component default will be used
	qps: float32 @go(QPS)

	// Maximum burst for throttle.
	// If it's zero, the component default will be used
	burst: int @go(Burst)
}

#RateLimiter: {
	tokenBucketRateLimiter?: null | #TokenBucketRateLimiter @go(TokenBucketRateLimiter,*TokenBucketRateLimiter)
}

// RESTClientConfiguration allows configuring certain aspects of the k8s rest client.
#RESTClientConfiguration: {
	//RateLimiter allows selecting and configuring different rate limiters for the k8s client.
	rateLimiter?: null | #RateLimiter @go(RateLimiter,*RateLimiter)
}

// ReloadableComponentConfiguration holds all generic k8s configuration options which can
// be reloaded by components without requiring a restart.
#ReloadableComponentConfiguration: {
	//RestClient can be used to tune certain aspects of the k8s client in use.
	restClient?: null | #RESTClientConfiguration @go(RestClient,*RESTClientConfiguration)
}

// KubeVirtConfiguration holds all kubevirt configurations
#KubeVirtConfiguration: {
	cpuModel?:               string                         @go(CPUModel)
	cpuRequest?:             null | resource.#Quantity      @go(CPURequest,*resource.Quantity)
	developerConfiguration?: null | #DeveloperConfiguration @go(DeveloperConfiguration,*DeveloperConfiguration)
	emulatedMachines?: [...string] @go(EmulatedMachines,[]string)
	imagePullPolicy?:     k8sv1.#PullPolicy              @go(ImagePullPolicy)
	migrations?:          null | #MigrationConfiguration @go(MigrationConfiguration,*MigrationConfiguration)
	machineType?:         string                         @go(MachineType)
	network?:             null | #NetworkConfiguration   @go(NetworkConfiguration,*NetworkConfiguration)
	ovmfPath?:            string                         @go(OVMFPath)
	selinuxLauncherType?: string                         @go(SELinuxLauncherType)
	defaultRuntimeClass?: string                         @go(DefaultRuntimeClass)
	smbios?:              null | #SMBiosConfiguration    @go(SMBIOSConfig,*SMBiosConfiguration)

	// EvictionStrategy defines at the cluster level if the VirtualMachineInstance should be
	// migrated instead of shut-off in case of a node drain. If the VirtualMachineInstance specific
	// field is set it overrides the cluster level one.
	evictionStrategy?: null | #EvictionStrategy @go(EvictionStrategy,*EvictionStrategy)

	// deprecated
	supportedGuestAgentVersions?: [...string] @go(SupportedGuestAgentVersions,[]string)
	memBalloonStatsPeriod?:        null | uint32                        @go(MemBalloonStatsPeriod,*uint32)
	permittedHostDevices?:         null | #PermittedHostDevices         @go(PermittedHostDevices,*PermittedHostDevices)
	mediatedDevicesConfiguration?: null | #MediatedDevicesConfiguration @go(MediatedDevicesConfiguration,*MediatedDevicesConfiguration)
	minCPUModel?:                  string                               @go(MinCPUModel)
	obsoleteCPUModels?: {[string]: bool} @go(ObsoleteCPUModels,map[string]bool)
	virtualMachineInstancesPerNode?: null | int                               @go(VirtualMachineInstancesPerNode,*int)
	apiConfiguration?:               null | #ReloadableComponentConfiguration @go(APIConfiguration,*ReloadableComponentConfiguration)
	webhookConfiguration?:           null | #ReloadableComponentConfiguration @go(WebhookConfiguration,*ReloadableComponentConfiguration)
	controllerConfiguration?:        null | #ReloadableComponentConfiguration @go(ControllerConfiguration,*ReloadableComponentConfiguration)
	handlerConfiguration?:           null | #ReloadableComponentConfiguration @go(HandlerConfiguration,*ReloadableComponentConfiguration)
	tlsConfiguration?:               null | #TLSConfiguration                 @go(TLSConfiguration,*TLSConfiguration)
	seccompConfiguration?:           null | #SeccompConfiguration             @go(SeccompConfiguration,*SeccompConfiguration)
}

#SMBiosConfiguration: {
	manufacturer?: string @go(Manufacturer)
	product?:      string @go(Product)
	version?:      string @go(Version)
	sku?:          string @go(Sku)
	family?:       string @go(Family)
}

#TLSProtocolVersion: string // #enumTLSProtocolVersion

#enumTLSProtocolVersion:
	#VersionTLS10 |
	#VersionTLS11 |
	#VersionTLS12 |
	#VersionTLS13

// VersionTLS10 is version 1.0 of the TLS security protocol.
#VersionTLS10: #TLSProtocolVersion & "VersionTLS10"

// VersionTLS11 is version 1.1 of the TLS security protocol.
#VersionTLS11: #TLSProtocolVersion & "VersionTLS11"

// VersionTLS12 is version 1.2 of the TLS security protocol.
#VersionTLS12: #TLSProtocolVersion & "VersionTLS12"

// VersionTLS13 is version 1.3 of the TLS security protocol.
#VersionTLS13: #TLSProtocolVersion & "VersionTLS13"

#CustomProfile: {
	localhostProfile?:      null | string @go(LocalhostProfile,*string)
	runtimeDefaultProfile?: bool          @go(RuntimeDefaultProfile)
}

#VirtualMachineInstanceProfile: {
	// CustomProfile allows to request arbitrary profile for virt-launcher
	customProfile?: null | #CustomProfile @go(CustomProfile,*CustomProfile)
}

// SeccompConfiguration holds Seccomp configuration for Kubevirt components
#SeccompConfiguration: {
	// VirtualMachineInstanceProfile defines what profile should be used with virt-launcher. Defaults to none
	virtualMachineInstanceProfile?: null | #VirtualMachineInstanceProfile @go(VirtualMachineInstanceProfile,*VirtualMachineInstanceProfile)
}

// TLSConfiguration holds TLS options
#TLSConfiguration: {
	// MinTLSVersion is a way to specify the minimum protocol version that is acceptable for TLS connections.
	// Protocol versions are based on the following most common TLS configurations:
	//
	//   https://ssl-config.mozilla.org/
	//
	// Note that SSLv3.0 is not a supported protocol version due to well known
	// vulnerabilities such as POODLE: https://en.wikipedia.org/wiki/POODLE
	// +kubebuilder:validation:Enum=VersionTLS10;VersionTLS11;VersionTLS12;VersionTLS13
	minTLSVersion?: #TLSProtocolVersion @go(MinTLSVersion)

	// +listType=set
	ciphers?: [...string] @go(Ciphers,[]string)
}

// MigrationConfiguration holds migration options.
// Can be overridden for specific groups of VMs though migration policies.
// Visit https://kubevirt.io/user-guide/operations/migration_policies/ for more information.
#MigrationConfiguration: {
	// NodeDrainTaintKey defines the taint key that indicates a node should be drained.
	// Note: this option relies on the deprecated node taint feature. Default: kubevirt.io/drain
	nodeDrainTaintKey?: null | string @go(NodeDrainTaintKey,*string)

	// ParallelOutboundMigrationsPerNode is the maximum number of concurrent outgoing live migrations
	// allowed per node. Defaults to 2
	parallelOutboundMigrationsPerNode?: null | uint32 @go(ParallelOutboundMigrationsPerNode,*uint32)

	// ParallelMigrationsPerCluster is the total number of concurrent live migrations
	// allowed cluster-wide. Defaults to 5
	parallelMigrationsPerCluster?: null | uint32 @go(ParallelMigrationsPerCluster,*uint32)

	// AllowAutoConverge allows the platform to compromise performance/availability of VMIs to
	// guarantee successful VMI live migrations. Defaults to false
	allowAutoConverge?: null | bool @go(AllowAutoConverge,*bool)

	// BandwidthPerMigration limits the amount of network bandwith live migrations are allowed to use.
	// The value is in quantity per second. Defaults to 0 (no limit)
	bandwidthPerMigration?: null | resource.#Quantity @go(BandwidthPerMigration,*resource.Quantity)

	// CompletionTimeoutPerGiB is the maximum number of seconds per GiB a migration is allowed to take.
	// If a live-migration takes longer to migrate than this value multiplied by the size of the VMI,
	// the migration will be cancelled, unless AllowPostCopy is true. Defaults to 800
	completionTimeoutPerGiB?: null | int64 @go(CompletionTimeoutPerGiB,*int64)

	// ProgressTimeout is the maximum number of seconds a live migration is allowed to make no progress.
	// Hitting this timeout means a migration transferred 0 data for that many seconds. The migration is
	// then considered stuck and therefore cancelled. Defaults to 150
	progressTimeout?: null | int64 @go(ProgressTimeout,*int64)

	// UnsafeMigrationOverride allows live migrations to occur even if the compatibility check
	// indicates the migration will be unsafe to the guest. Defaults to false
	unsafeMigrationOverride?: null | bool @go(UnsafeMigrationOverride,*bool)

	// AllowPostCopy enables post-copy live migrations. Such migrations allow even the busiest VMIs
	// to successfully live-migrate. However, events like a network failure can cause a VMI crash.
	// If set to true, migrations will still start in pre-copy, but switch to post-copy when
	// CompletionTimeoutPerGiB triggers. Defaults to false
	allowPostCopy?: null | bool @go(AllowPostCopy,*bool)

	// When set to true, DisableTLS will disable the additional layer of live migration encryption
	// provided by KubeVirt. This is usually a bad idea. Defaults to false
	disableTLS?: null | bool @go(DisableTLS,*bool)

	// Network is the name of the CNI network to use for live migrations. By default, migrations go
	// through the pod network.
	network?: null | string @go(Network,*string)
}

// DiskVerification holds container disks verification limits
#DiskVerification: {
	memoryLimit?: null | resource.#Quantity @go(MemoryLimit,*resource.Quantity)
}

// DeveloperConfiguration holds developer options
#DeveloperConfiguration: {
	// FeatureGates is the list of experimental features to enable. Defaults to none
	featureGates?: [...string] @go(FeatureGates,[]string)

	// LessPVCSpaceToleration determines how much smaller, in percentage, disk PVCs are
	// allowed to be compared to the requested size (to account for various overheads).
	// Defaults to 10
	pvcTolerateLessSpaceUpToPercent?: int @go(LessPVCSpaceToleration)

	// MinimumReservePVCBytes is the amount of space, in bytes, to leave unused on disks.
	// Defaults to 131072 (128KiB)
	minimumReservePVCBytes?: uint64 @go(MinimumReservePVCBytes)

	// MemoryOvercommit is the percentage of memory we want to give VMIs compared to the amount
	// given to its parent pod (virt-launcher). For example, a value of 102 means the VMI will
	// "see" 2% more memory than its parent pod. Values under 100 are effectively "undercommits".
	// Overcommits can lead to memory exhaustion, which in turn can lead to crashes. Use carefully.
	// Defaults to 100
	memoryOvercommit?: int @go(MemoryOvercommit)

	// NodeSelectors allows restricting VMI creation to nodes that match a set of labels.
	// Defaults to none
	nodeSelectors?: {[string]: string} @go(NodeSelectors,map[string]string)

	// UseEmulation can be set to true to allow fallback to software emulation
	// in case hardware-assisted emulation is not available. Defaults to false
	useEmulation?: bool @go(UseEmulation)

	// For each requested virtual CPU, CPUAllocationRatio defines how much physical CPU to request per VMI
	// from the hosting node. The value is in fraction of a CPU thread (or core on non-hyperthreaded nodes).
	// For example, a value of 1 means 1 physical CPU thread per VMI CPU thread.
	// A value of 100 would be 1% of a physical thread allocated for each requested VMI thread.
	// This option has no effect on VMIs that request dedicated CPUs. More information at:
	// https://kubevirt.io/user-guide/operations/node_overcommit/#node-cpu-allocation-ratio
	// Defaults to 10
	cpuAllocationRatio?: int @go(CPUAllocationRatio)

	// Allow overriding the automatically determined minimum TSC frequency of the cluster
	// and fixate the minimum to this frequency.
	minimumClusterTSCFrequency?: null | int64             @go(MinimumClusterTSCFrequency,*int64)
	diskVerification?:           null | #DiskVerification @go(DiskVerification,*DiskVerification)
	logVerbosity?:               null | #LogVerbosity     @go(LogVerbosity,*LogVerbosity)
}

// LogVerbosity sets log verbosity level of  various components
#LogVerbosity: {
	virtAPI?:        uint @go(VirtAPI)
	virtController?: uint @go(VirtController)
	virtHandler?:    uint @go(VirtHandler)
	virtLauncher?:   uint @go(VirtLauncher)
	virtOperator?:   uint @go(VirtOperator)

	// NodeVerbosity represents a map of nodes with a specific verbosity level
	nodeVerbosity?: {[string]: uint} @go(NodeVerbosity,map[string]uint)
}

#PCIResourcePrefix:  "PCI_RESOURCE"
#MDevResourcePrefix: "MDEV_PCI_RESOURCE"

// PermittedHostDevices holds information about devices allowed for passthrough
#PermittedHostDevices: {
	// +listType=atomic
	pciHostDevices?: [...#PciHostDevice] @go(PciHostDevices,[]PciHostDevice)

	// +listType=atomic
	mediatedDevices?: [...#MediatedHostDevice] @go(MediatedDevices,[]MediatedHostDevice)
}

// PciHostDevice represents a host PCI device allowed for passthrough
#PciHostDevice: {
	// The vendor_id:product_id tuple of the PCI device
	pciVendorSelector: string @go(PCIVendorSelector)

	// The name of the resource that is representing the device. Exposed by
	// a device plugin and requested by VMs. Typically of the form
	// vendor.com/product_nameThe name of the resource that is representing
	// the device. Exposed by a device plugin and requested by VMs.
	// Typically of the form vendor.com/product_name
	resourceName: string @go(ResourceName)

	// If true, KubeVirt will leave the allocation and monitoring to an
	// external device plugin
	externalResourceProvider?: bool @go(ExternalResourceProvider)
}

// MediatedHostDevice represents a host mediated device allowed for passthrough
#MediatedHostDevice: {
	mdevNameSelector:          string @go(MDEVNameSelector)
	resourceName:              string @go(ResourceName)
	externalResourceProvider?: bool   @go(ExternalResourceProvider)
}

// MediatedDevicesConfiguration holds information about MDEV types to be defined, if available
#MediatedDevicesConfiguration: {
	// Deprecated. Use mediatedDeviceTypes instead.
	// +optional
	// +listType=atomic
	mediatedDevicesTypes?: [...string] @go(MediatedDevicesTypes,[]string)

	// +optional
	// +listType=atomic
	mediatedDeviceTypes?: [...string] @go(MediatedDeviceTypes,[]string)

	// +optional
	// +listType=atomic
	nodeMediatedDeviceTypes?: [...#NodeMediatedDeviceTypesConfig] @go(NodeMediatedDeviceTypes,[]NodeMediatedDeviceTypesConfig)
}

// NodeMediatedDeviceTypesConfig holds information about MDEV types to be defined in a specifc node that matches the NodeSelector field.
// +k8s:openapi-gen=true
#NodeMediatedDeviceTypesConfig: {
	// NodeSelector is a selector which must be true for the vmi to fit on a node.
	// Selector which must match a node's labels for the vmi to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	nodeSelector: {[string]: string} @go(NodeSelector,map[string]string)

	// Deprecated. Use mediatedDeviceTypes instead.
	// +optional
	// +listType=atomic
	mediatedDevicesTypes?: [...string] @go(MediatedDevicesTypes,[]string)

	// +optional
	// +listType=atomic
	mediatedDeviceTypes: [...string] @go(MediatedDeviceTypes,[]string)
}

// NetworkConfiguration holds network options
#NetworkConfiguration: {
	defaultNetworkInterface?:           string      @go(NetworkInterface)
	permitSlirpInterface?:              null | bool @go(PermitSlirpInterface,*bool)
	permitBridgeInterfaceOnPodNetwork?: null | bool @go(PermitBridgeInterfaceOnPodNetwork,*bool)
}

// GuestAgentPing configures the guest-agent based ping probe
#GuestAgentPing: {
}

#ProfilerResult: {
	pprofData?: {[string]: bytes} @go(PprofData,map[string][]byte)
}

#ClusterProfilerResults: {
	componentResults: {[string]: #ProfilerResult} @go(ComponentResults,map[string]ProfilerResult)
	continue?: string @go(Continue)
}

#ClusterProfilerRequest: {
	labelSelector?: string @go(LabelSelector)
	continue?:      string @go(Continue)
	pageSize:       int64  @go(PageSize)
}

// InstancetypeMatcher references a instancetype that is used to fill fields in the VMI template.
#InstancetypeMatcher: {
	// Name is the name of the VirtualMachineInstancetype or VirtualMachineClusterInstancetype
	//
	// +optional
	name?: string @go(Name)

	// Kind specifies which instancetype resource is referenced.
	// Allowed values are: "VirtualMachineInstancetype" and "VirtualMachineClusterInstancetype".
	// If not specified, "VirtualMachineClusterInstancetype" is used by default.
	//
	// +optional
	kind?: string @go(Kind)

	// RevisionName specifies a ControllerRevision containing a specific copy of the
	// VirtualMachineInstancetype or VirtualMachineClusterInstancetype to be used. This is initially
	// captured the first time the instancetype is applied to the VirtualMachineInstance.
	//
	// +optional
	revisionName?: string @go(RevisionName)

	// InferFromVolume lists the name of a volume that should be used to infer or discover the instancetype
	// to be used through known annotations on the underlying resource. Once applied to the InstancetypeMatcher
	// this field is removed.
	//
	// +optional
	inferFromVolume?: string @go(InferFromVolume)
}

// PreferenceMatcher references a set of preference that is used to fill fields in the VMI template.
#PreferenceMatcher: {
	// Name is the name of the VirtualMachinePreference or VirtualMachineClusterPreference
	//
	// +optional
	name?: string @go(Name)

	// Kind specifies which preference resource is referenced.
	// Allowed values are: "VirtualMachinePreference" and "VirtualMachineClusterPreference".
	// If not specified, "VirtualMachineClusterPreference" is used by default.
	//
	// +optional
	kind?: string @go(Kind)

	// RevisionName specifies a ControllerRevision containing a specific copy of the
	// VirtualMachinePreference or VirtualMachineClusterPreference to be used. This is
	// initially captured the first time the instancetype is applied to the VirtualMachineInstance.
	//
	// +optional
	revisionName?: string @go(RevisionName)

	// InferFromVolume lists the name of a volume that should be used to infer or discover the preference
	// to be used through known annotations on the underlying resource. Once applied to the PreferenceMatcher
	// this field is removed.
	//
	// +optional
	inferFromVolume?: string @go(InferFromVolume)
}
