// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go kubevirt.io/api/core/v1

package v1

import (
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
)

#IOThreadsPolicy: string // #enumIOThreadsPolicy

#enumIOThreadsPolicy:
	#IOThreadsPolicyShared |
	#IOThreadsPolicyAuto

#IOThreadsPolicyShared:  #IOThreadsPolicy & "shared"
#IOThreadsPolicyAuto:    #IOThreadsPolicy & "auto"
#CPUModeHostPassthrough: "host-passthrough"
#CPUModeHostModel:       "host-model"
#DefaultCPUModel:        "host-model"

#HotplugDiskDir: "/var/run/kubevirt/hotplug-disks/"

// Represents a disk created on the cluster level
#HostDisk: {
	// The path to HostDisk image located on the cluster
	path: string @go(Path)

	// Contains information if disk.img exists or should be created
	// allowed options are 'Disk' and 'DiskOrCreate'
	type: #HostDiskType @go(Type)

	// Capacity of the sparse disk
	// +optional
	capacity?: resource.#Quantity @go(Capacity)

	// Shared indicate whether the path is shared between nodes
	shared?: null | bool @go(Shared,*bool)
}

// ConfigMapVolumeSource adapts a ConfigMap into a volume.
// More info: https://kubernetes.io/docs/concepts/storage/volumes/#configmap
#ConfigMapVolumeSource: {
	v1.#LocalObjectReference

	// Specify whether the ConfigMap or it's keys must be defined
	// +optional
	optional?: null | bool @go(Optional,*bool)

	// The volume label of the resulting disk inside the VMI.
	// Different bootstrapping mechanisms require different values.
	// Typical values are "cidata" (cloud-init), "config-2" (cloud-init) or "OEMDRV" (kickstart).
	// +optional
	volumeLabel?: string @go(VolumeLabel)
}

// SecretVolumeSource adapts a Secret into a volume.
#SecretVolumeSource: {
	// Name of the secret in the pod's namespace to use.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	// +optional
	secretName?: string @go(SecretName)

	// Specify whether the Secret or it's keys must be defined
	// +optional
	optional?: null | bool @go(Optional,*bool)

	// The volume label of the resulting disk inside the VMI.
	// Different bootstrapping mechanisms require different values.
	// Typical values are "cidata" (cloud-init), "config-2" (cloud-init) or "OEMDRV" (kickstart).
	// +optional
	volumeLabel?: string @go(VolumeLabel)
}

// DownwardAPIVolumeSource represents a volume containing downward API info.
#DownwardAPIVolumeSource: {
	// Fields is a list of downward API volume file
	// +optional
	fields?: [...v1.#DownwardAPIVolumeFile] @go(Fields,[]v1.DownwardAPIVolumeFile)

	// The volume label of the resulting disk inside the VMI.
	// Different bootstrapping mechanisms require different values.
	// Typical values are "cidata" (cloud-init), "config-2" (cloud-init) or "OEMDRV" (kickstart).
	// +optional
	volumeLabel?: string @go(VolumeLabel)
}

// ServiceAccountVolumeSource adapts a ServiceAccount into a volume.
#ServiceAccountVolumeSource: {
	// Name of the service account in the pod's namespace to use.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	serviceAccountName?: string @go(ServiceAccountName)
}

// DownwardMetricsVolumeSource adds a very small disk to VMIs which contains a limited view of host and guest
// metrics. The disk content is compatible with vhostmd (https://github.com/vhostmd/vhostmd) and vm-dump-metrics.
#DownwardMetricsVolumeSource: {
}

// Represents a Sysprep volume source.
#SysprepSource: {
	// Secret references a k8s Secret that contains Sysprep answer file named autounattend.xml that should be attached as disk of CDROM type.
	// + optional
	secret?: null | v1.#LocalObjectReference @go(Secret,*v1.LocalObjectReference)

	// ConfigMap references a ConfigMap that contains Sysprep answer file named autounattend.xml that should be attached as disk of CDROM type.
	// + optional
	configMap?: null | v1.#LocalObjectReference @go(ConfigMap,*v1.LocalObjectReference)
}

// Represents a cloud-init nocloud user data source.
// More info: http://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html
#CloudInitNoCloudSource: {
	// UserDataSecretRef references a k8s secret that contains NoCloud userdata.
	// + optional
	secretRef?: null | v1.#LocalObjectReference @go(UserDataSecretRef,*v1.LocalObjectReference)

	// UserDataBase64 contains NoCloud cloud-init userdata as a base64 encoded string.
	// + optional
	userDataBase64?: string @go(UserDataBase64)

	// UserData contains NoCloud inline cloud-init userdata.
	// + optional
	userData?: string @go(UserData)

	// NetworkDataSecretRef references a k8s secret that contains NoCloud networkdata.
	// + optional
	networkDataSecretRef?: null | v1.#LocalObjectReference @go(NetworkDataSecretRef,*v1.LocalObjectReference)

	// NetworkDataBase64 contains NoCloud cloud-init networkdata as a base64 encoded string.
	// + optional
	networkDataBase64?: string @go(NetworkDataBase64)

	// NetworkData contains NoCloud inline cloud-init networkdata.
	// + optional
	networkData?: string @go(NetworkData)
}

// Represents a cloud-init config drive user data source.
// More info: https://cloudinit.readthedocs.io/en/latest/topics/datasources/configdrive.html
#CloudInitConfigDriveSource: {
	// UserDataSecretRef references a k8s secret that contains config drive userdata.
	// + optional
	secretRef?: null | v1.#LocalObjectReference @go(UserDataSecretRef,*v1.LocalObjectReference)

	// UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
	// + optional
	userDataBase64?: string @go(UserDataBase64)

	// UserData contains config drive inline cloud-init userdata.
	// + optional
	userData?: string @go(UserData)

	// NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
	// + optional
	networkDataSecretRef?: null | v1.#LocalObjectReference @go(NetworkDataSecretRef,*v1.LocalObjectReference)

	// NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
	// + optional
	networkDataBase64?: string @go(NetworkDataBase64)

	// NetworkData contains config drive inline cloud-init networkdata.
	// + optional
	networkData?: string @go(NetworkData)
}

#DomainSpec: {
	// Resources describes the Compute Resources required by this vmi.
	resources?: #ResourceRequirements @go(Resources)

	// CPU allow specified the detailed CPU topology inside the vmi.
	// +optional
	cpu?: null | #CPU @go(CPU,*CPU)

	// Memory allow specifying the VMI memory features.
	// +optional
	memory?: null | #Memory @go(Memory,*Memory)

	// Machine type.
	// +optional
	machine?: null | #Machine @go(Machine,*Machine)

	// Firmware.
	// +optional
	firmware?: null | #Firmware @go(Firmware,*Firmware)

	// Clock sets the clock and timers of the vmi.
	// +optional
	clock?: null | #Clock @go(Clock,*Clock)

	// Features like acpi, apic, hyperv, smm.
	// +optional
	features?: null | #Features @go(Features,*Features)

	// Devices allows adding disks, network interfaces, and others
	devices: #Devices @go(Devices)

	// Controls whether or not disks will share IOThreads.
	// Omitting IOThreadsPolicy disables use of IOThreads.
	// One of: shared, auto
	// +optional
	ioThreadsPolicy?: null | #IOThreadsPolicy @go(IOThreadsPolicy,*IOThreadsPolicy)

	// Chassis specifies the chassis info passed to the domain.
	// +optional
	chassis?: null | #Chassis @go(Chassis,*Chassis)

	// Launch Security setting of the vmi.
	// +optional
	launchSecurity?: null | #LaunchSecurity @go(LaunchSecurity,*LaunchSecurity)
}

// Chassis specifies the chassis info passed to the domain.
#Chassis: {
	manufacturer?: string @go(Manufacturer)
	version?:      string @go(Version)
	serial?:       string @go(Serial)
	asset?:        string @go(Asset)
	sku?:          string @go(Sku)
}

// Represents the firmware blob used to assist in the domain creation process.
// Used for setting the QEMU BIOS file path for the libvirt domain.
#Bootloader: {
	// If set (default), BIOS will be used.
	// +optional
	bios?: null | #BIOS @go(BIOS,*BIOS)

	// If set, EFI will be used instead of BIOS.
	// +optional
	efi?: null | #EFI @go(EFI,*EFI)
}

// If set (default), BIOS will be used.
#BIOS: {
	// If set, the BIOS output will be transmitted over serial
	// +optional
	useSerial?: null | bool @go(UseSerial,*bool)
}

// If set, EFI will be used instead of BIOS.
#EFI: {
	// If set, SecureBoot will be enabled and the OVMF roms will be swapped for
	// SecureBoot-enabled ones.
	// Requires SMM to be enabled.
	// Defaults to true
	// +optional
	secureBoot?: null | bool @go(SecureBoot,*bool)
}

// If set, the VM will be booted from the defined kernel / initrd.
#KernelBootContainer: {
	// Image that contains initrd / kernel files.
	image: string @go(Image)

	// ImagePullSecret is the name of the Docker registry secret required to pull the image. The secret must already exist.
	//+optional
	imagePullSecret?: string @go(ImagePullSecret)

	// Image pull policy.
	// One of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	imagePullPolicy?: v1.#PullPolicy @go(ImagePullPolicy)

	// The fully-qualified path to the kernel image in the host OS
	//+optional
	kernelPath?: string @go(KernelPath)

	// the fully-qualified path to the ramdisk image in the host OS
	//+optional
	initrdPath?: string @go(InitrdPath)
}

// Represents the firmware blob used to assist in the kernel boot process.
// Used for setting the kernel, initrd and command line arguments
#KernelBoot: {
	// Arguments to be passed to the kernel at boot time
	kernelArgs?: string @go(KernelArgs)

	// Container defines the container that containes kernel artifacts
	container?: null | #KernelBootContainer @go(Container,*KernelBootContainer)
}

#ResourceRequirements: {
	// Requests is a description of the initial vmi resources.
	// Valid resource keys are "memory" and "cpu".
	// +optional
	requests?: v1.#ResourceList @go(Requests)

	// Limits describes the maximum amount of compute resources allowed.
	// Valid resource keys are "memory" and "cpu".
	// +optional
	limits?: v1.#ResourceList @go(Limits)

	// Don't ask the scheduler to take the guest-management overhead into account. Instead
	// put the overhead only into the container's memory limit. This can lead to crashes if
	// all memory is in use on a node. Defaults to false.
	overcommitGuestOverhead?: bool @go(OvercommitGuestOverhead)
}

// CPU allows specifying the CPU topology.
#CPU: {
	// Cores specifies the number of cores inside the vmi.
	// Must be a value greater or equal 1.
	cores?: uint32 @go(Cores)

	// Sockets specifies the number of sockets inside the vmi.
	// Must be a value greater or equal 1.
	sockets?: uint32 @go(Sockets)

	// Threads specifies the number of threads inside the vmi.
	// Must be a value greater or equal 1.
	threads?: uint32 @go(Threads)

	// Model specifies the CPU model inside the VMI.
	// List of available models https://github.com/libvirt/libvirt/tree/master/src/cpu_map.
	// It is possible to specify special cases like "host-passthrough" to get the same CPU as the node
	// and "host-model" to get CPU closest to the node one.
	// Defaults to host-model.
	// +optional
	model?: string @go(Model)

	// Features specifies the CPU features list inside the VMI.
	// +optional
	features?: [...#CPUFeature] @go(Features,[]CPUFeature)

	// DedicatedCPUPlacement requests the scheduler to place the VirtualMachineInstance on a node
	// with enough dedicated pCPUs and pin the vCPUs to it.
	// +optional
	dedicatedCpuPlacement?: bool @go(DedicatedCPUPlacement)

	// NUMA allows specifying settings for the guest NUMA topology
	// +optional
	numa?: null | #NUMA @go(NUMA,*NUMA)

	// IsolateEmulatorThread requests one more dedicated pCPU to be allocated for the VMI to place
	// the emulator thread on it.
	// +optional
	isolateEmulatorThread?: bool @go(IsolateEmulatorThread)

	// Realtime instructs the virt-launcher to tune the VMI for lower latency, optional for real time workloads
	// +optional
	realtime?: null | #Realtime @go(Realtime,*Realtime)
}

// Realtime holds the tuning knobs specific for realtime workloads.
#Realtime: {
	// Mask defines the vcpu mask expression that defines which vcpus are used for realtime. Format matches libvirt's expressions.
	// Example: "0-3,^1","0,2,3","2-3"
	// +optional
	mask?: string @go(Mask)
}

// NUMAGuestMappingPassthrough instructs kubevirt to model numa topology which is compatible with the CPU pinning on the guest.
// This will result in a subset of the node numa topology being passed through, ensuring that virtual numa nodes and their memory
// never cross boundaries coming from the node numa mapping.
#NUMAGuestMappingPassthrough: {
}

#NUMA: {
	// GuestMappingPassthrough will create an efficient guest topology based on host CPUs exclusively assigned to a pod.
	// The created topology ensures that memory and CPUs on the virtual numa nodes never cross boundaries of host numa nodes.
	// +opitonal
	guestMappingPassthrough?: null | #NUMAGuestMappingPassthrough @go(GuestMappingPassthrough,*NUMAGuestMappingPassthrough)
}

// CPUFeature allows specifying a CPU feature.
#CPUFeature: {
	// Name of the CPU feature
	name: string @go(Name)

	// Policy is the CPU feature attribute which can have the following attributes:
	// force    - The virtual CPU will claim the feature is supported regardless of it being supported by host CPU.
	// require  - Guest creation will fail unless the feature is supported by the host CPU or the hypervisor is able to emulate it.
	// optional - The feature will be supported by virtual CPU if and only if it is supported by host CPU.
	// disable  - The feature will not be supported by virtual CPU.
	// forbid   - Guest creation will fail if the feature is supported by host CPU.
	// Defaults to require
	// +optional
	policy?: string @go(Policy)
}

// Memory allows specifying the VirtualMachineInstance memory features.
#Memory: {
	// Hugepages allow to use hugepages for the VirtualMachineInstance instead of regular memory.
	// +optional
	hugepages?: null | #Hugepages @go(Hugepages,*Hugepages)

	// Guest allows to specifying the amount of memory which is visible inside the Guest OS.
	// The Guest must lie between Requests and Limits from the resources section.
	// Defaults to the requested memory in the resources section if not specified.
	// + optional
	guest?: null | resource.#Quantity @go(Guest,*resource.Quantity)
}

// Hugepages allow to use hugepages for the VirtualMachineInstance instead of regular memory.
#Hugepages: {
	// PageSize specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
	pageSize?: string @go(PageSize)
}

#Machine: {
	// QEMU machine type is the actual chipset of the VirtualMachineInstance.
	// +optional
	type: string @go(Type)
}

#Firmware: {
	// UUID reported by the vmi bios.
	// Defaults to a random generated uid.
	uuid?: types.#UID @go(UUID)

	// Settings to control the bootloader that is used.
	// +optional
	bootloader?: null | #Bootloader @go(Bootloader,*Bootloader)

	// The system-serial-number in SMBIOS
	serial?: string @go(Serial)

	// Settings to set the kernel for booting.
	// +optional
	kernelBoot?: null | #KernelBoot @go(KernelBoot,*KernelBoot)
}

#Devices: {
	// Fall back to legacy virtio 0.9 support if virtio bus is selected on devices.
	// This is helpful for old machines like CentOS6 or RHEL6 which
	// do not understand virtio_non_transitional (virtio 1.0).
	useVirtioTransitional?: null | bool @go(UseVirtioTransitional,*bool)

	// DisableHotplug disabled the ability to hotplug disks.
	disableHotplug?: bool @go(DisableHotplug)

	// Disks describes disks, cdroms and luns which are connected to the vmi.
	disks?: [...#Disk] @go(Disks,[]Disk)

	// Watchdog describes a watchdog device which can be added to the vmi.
	watchdog?: null | #Watchdog @go(Watchdog,*Watchdog)

	// Interfaces describe network interfaces which are added to the vmi.
	interfaces?: [...#Interface] @go(Interfaces,[]Interface)

	// Inputs describe input devices
	inputs?: [...#Input] @go(Inputs,[]Input)

	// Whether to attach a pod network interface. Defaults to true.
	autoattachPodInterface?: null | bool @go(AutoattachPodInterface,*bool)

	// Whether to attach the default graphics device or not.
	// VNC will not be available if set to false. Defaults to true.
	autoattachGraphicsDevice?: null | bool @go(AutoattachGraphicsDevice,*bool)

	// Whether to attach the default serial console or not.
	// Serial console access will not be available if set to false. Defaults to true.
	autoattachSerialConsole?: null | bool @go(AutoattachSerialConsole,*bool)

	// Whether to attach the Memory balloon device with default period.
	// Period can be adjusted in virt-config.
	// Defaults to true.
	// +optional
	autoattachMemBalloon?: null | bool @go(AutoattachMemBalloon,*bool)

	// Whether to attach an Input Device.
	// Defaults to false.
	// +optional
	autoattachInputDevice?: null | bool @go(AutoattachInputDevice,*bool)

	// Whether to attach the VSOCK CID to the VM or not.
	// VSOCK access will be available if set to true. Defaults to false.
	autoattachVSOCK?: null | bool @go(AutoattachVSOCK,*bool)

	// Whether to have random number generator from host
	// +optional
	rng?: null | #Rng @go(Rng,*Rng)

	// Whether or not to enable virtio multi-queue for block devices.
	// Defaults to false.
	// +optional
	blockMultiQueue?: null | bool @go(BlockMultiQueue,*bool)

	// If specified, virtual network interfaces configured with a virtio bus will also enable the vhost multiqueue feature for network devices. The number of queues created depends on additional factors of the VirtualMachineInstance, like the number of guest CPUs.
	// +optional
	networkInterfaceMultiqueue?: null | bool @go(NetworkInterfaceMultiQueue,*bool)

	//Whether to attach a GPU device to the vmi.
	// +optional
	// +listType=atomic
	gpus?: [...#GPU] @go(GPUs,[]GPU)

	// Filesystems describes filesystem which is connected to the vmi.
	// +optional
	// +listType=atomic
	filesystems?: [...#Filesystem] @go(Filesystems,[]Filesystem)

	//Whether to attach a host device to the vmi.
	// +optional
	// +listType=atomic
	hostDevices?: [...#HostDevice] @go(HostDevices,[]HostDevice)

	// To configure and access client devices such as redirecting USB
	// +optional
	clientPassthrough?: null | #ClientPassthroughDevices @go(ClientPassthrough,*ClientPassthroughDevices)

	// Whether to emulate a sound device.
	// +optional
	sound?: null | #SoundDevice @go(Sound,*SoundDevice)

	// Whether to emulate a TPM device.
	// +optional
	tpm?: null | #TPMDevice @go(TPM,*TPMDevice)
}

// Represent a subset of client devices that can be accessed by VMI. At the
// moment only, USB devices using Usbredir's library and tooling. Another fit
// would be a smartcard with libcacard.
//
// The struct is currently empty as there is no immediate request for
// user-facing APIs. This structure simply turns on USB redirection of
// UsbClientPassthroughMaxNumberOf devices.
#ClientPassthroughDevices: {
}

#UsbClientPassthroughMaxNumberOf: 4

// Represents the user's configuration to emulate sound cards in the VMI.
#SoundDevice: {
	// User's defined name for this sound device
	name: string @go(Name)

	// We only support ich9 or ac97.
	// If SoundDevice is not set: No sound card is emulated.
	// If SoundDevice is set but Model is not: ich9
	// +optional
	model?: string @go(Model)
}

#TPMDevice: {
}

#InputBus: string // #enumInputBus

#enumInputBus:
	#InputBusUSB |
	#InputBusVirtio

#InputBusUSB:    #InputBus & "usb"
#InputBusVirtio: #InputBus & "virtio"

#InputType: string // #enumInputType

#enumInputType:
	#InputTypeTablet |
	#InputTypeKeyboard

#InputTypeTablet:   #InputType & "tablet"
#InputTypeKeyboard: #InputType & "keyboard"

#Input: {
	// Bus indicates the bus of input device to emulate.
	// Supported values: virtio, usb.
	bus?: #InputBus @go(Bus)

	// Type indicated the type of input device.
	// Supported values: tablet.
	type: #InputType @go(Type)

	// Name is the device name
	name: string @go(Name)
}

#Filesystem: {
	// Name is the device name
	name: string @go(Name)

	// Virtiofs is supported
	virtiofs?: null | #FilesystemVirtiofs @go(Virtiofs,*FilesystemVirtiofs)
}

#FilesystemVirtiofs: {
}

#GPU: {
	// Name of the GPU device as exposed by a device plugin
	name:               string              @go(Name)
	deviceName:         string              @go(DeviceName)
	virtualGPUOptions?: null | #VGPUOptions @go(VirtualGPUOptions,*VGPUOptions)

	// If specified, the virtual network interface address and its tag will be provided to the guest via config drive
	// +optional
	tag?: string @go(Tag)
}

#VGPUOptions: {
	display?: null | #VGPUDisplayOptions @go(Display,*VGPUDisplayOptions)
}

#VGPUDisplayOptions: {
	// Enabled determines if a display addapter backed by a vGPU should be enabled or disabled on the guest.
	// Defaults to true.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// Enables a boot framebuffer, until the guest OS loads a real GPU driver
	// Defaults to true.
	// +optional
	ramFB?: null | #FeatureState @go(RamFB,*FeatureState)
}

#HostDevice: {
	name: string @go(Name)

	// DeviceName is the resource name of the host device exposed by a device plugin
	deviceName: string @go(DeviceName)

	// If specified, the virtual network interface address and its tag will be provided to the guest via config drive
	// +optional
	tag?: string @go(Tag)
}

#Disk: {
	// Name is the device name
	name: string @go(Name)

	#DiskDevice

	// BootOrder is an integer value > 0, used to determine ordering of boot devices.
	// Lower values take precedence.
	// Each disk or interface that has a boot order must have a unique value.
	// Disks without a boot order are not tried if a disk with a boot order exists.
	// +optional
	bootOrder?: null | uint @go(BootOrder,*uint)

	// Serial provides the ability to specify a serial number for the disk device.
	// +optional
	serial?: string @go(Serial)

	// dedicatedIOThread indicates this disk should have an exclusive IO Thread.
	// Enabling this implies useIOThreads = true.
	// Defaults to false.
	// +optional
	dedicatedIOThread?: null | bool @go(DedicatedIOThread,*bool)

	// Cache specifies which kvm disk cache mode should be used.
	// Supported values are: CacheNone, CacheWriteThrough.
	// +optional
	cache?: #DriverCache @go(Cache)

	// IO specifies which QEMU disk IO mode should be used.
	// Supported values are: native, default, threads.
	// +optional
	io?: #DriverIO @go(IO)

	// If specified, disk address and its tag will be provided to the guest via config drive metadata
	// +optional
	tag?: string @go(Tag)

	// If specified, the virtual disk will be presented with the given block sizes.
	// +optional
	blockSize?: null | #BlockSize @go(BlockSize,*BlockSize)

	// If specified the disk is made sharable and multiple write from different VMs are permitted
	// +optional
	shareable?: null | bool @go(Shareable,*bool)
}

// CustomBlockSize represents the desired logical and physical block size for a VM disk.
#CustomBlockSize: {
	logical:  uint @go(Logical)
	physical: uint @go(Physical)
}

// BlockSize provides the option to change the block size presented to the VM for a disk.
// Only one of its members may be specified.
#BlockSize: {
	custom?:      null | #CustomBlockSize @go(Custom,*CustomBlockSize)
	matchVolume?: null | #FeatureState    @go(MatchVolume,*FeatureState)
}

// Represents the target of a volume to mount.
// Only one of its members may be specified.
#DiskDevice: {
	// Attach a volume as a disk to the vmi.
	disk?: null | #DiskTarget @go(Disk,*DiskTarget)

	// Attach a volume as a LUN to the vmi.
	lun?: null | #LunTarget @go(LUN,*LunTarget)

	// Attach a volume as a cdrom to the vmi.
	cdrom?: null | #CDRomTarget @go(CDRom,*CDRomTarget)
}

#DiskBus: string // #enumDiskBus

#enumDiskBus:
	#DiskBusSCSI |
	#DiskBusSATA |
	#DiskBusVirtio |
	#DiskBusUSB

#DiskBusSCSI:   #DiskBus & "scsi"
#DiskBusSATA:   #DiskBus & "sata"
#DiskBusVirtio: #DiskBus & "virtio"
#DiskBusUSB:    #DiskBus & "usb"

#DiskTarget: {
	// Bus indicates the type of disk device to emulate.
	// supported values: virtio, sata, scsi, usb.
	bus?: #DiskBus @go(Bus)

	// ReadOnly.
	// Defaults to false.
	readonly?: bool @go(ReadOnly)

	// If specified, the virtual disk will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10
	// +optional
	pciAddress?: string @go(PciAddress)
}

#LaunchSecurity: {
	// AMD Secure Encrypted Virtualization (SEV).
	sev?: null | #SEV @go(SEV,*SEV)
}

#SEV: {
}

#LunTarget: {
	// Bus indicates the type of disk device to emulate.
	// supported values: virtio, sata, scsi.
	bus?: #DiskBus @go(Bus)

	// ReadOnly.
	// Defaults to false.
	readonly?: bool @go(ReadOnly)
}

// TrayState indicates if a tray of a cdrom is open or closed.
#TrayState: string // #enumTrayState

#enumTrayState:
	#TrayStateOpen |
	#TrayStateClosed

// TrayStateOpen indicates that the tray of a cdrom is open.
#TrayStateOpen: #TrayState & "open"

// TrayStateClosed indicates that the tray of a cdrom is closed.
#TrayStateClosed: #TrayState & "closed"

#CDRomTarget: {
	// Bus indicates the type of disk device to emulate.
	// supported values: virtio, sata, scsi.
	bus?: #DiskBus @go(Bus)

	// ReadOnly.
	// Defaults to true.
	readonly?: null | bool @go(ReadOnly,*bool)

	// Tray indicates if the tray of the device is open or closed.
	// Allowed values are "open" and "closed".
	// Defaults to closed.
	// +optional
	tray?: #TrayState @go(Tray)
}

// Volume represents a named volume in a vmi.
#Volume: {
	// Volume's name.
	// Must be a DNS_LABEL and unique within the vmi.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	name: string @go(Name)

	#VolumeSource
}

// Represents the source of a volume to mount.
// Only one of its members may be specified.
#VolumeSource: {
	// HostDisk represents a disk created on the cluster level
	// +optional
	hostDisk?: null | #HostDisk @go(HostDisk,*HostDisk)

	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	// Directly attached to the vmi via qemu.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	persistentVolumeClaim?: null | #PersistentVolumeClaimVolumeSource @go(PersistentVolumeClaim,*PersistentVolumeClaimVolumeSource)

	// CloudInitNoCloud represents a cloud-init NoCloud user-data source.
	// The NoCloud data will be added as a disk to the vmi. A proper cloud-init installation is required inside the guest.
	// More info: http://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html
	// +optional
	cloudInitNoCloud?: null | #CloudInitNoCloudSource @go(CloudInitNoCloud,*CloudInitNoCloudSource)

	// CloudInitConfigDrive represents a cloud-init Config Drive user-data source.
	// The Config Drive data will be added as a disk to the vmi. A proper cloud-init installation is required inside the guest.
	// More info: https://cloudinit.readthedocs.io/en/latest/topics/datasources/configdrive.html
	// +optional
	cloudInitConfigDrive?: null | #CloudInitConfigDriveSource @go(CloudInitConfigDrive,*CloudInitConfigDriveSource)

	// Represents a Sysprep volume source.
	// +optional
	sysprep?: null | #SysprepSource @go(Sysprep,*SysprepSource)

	// ContainerDisk references a docker image, embedding a qcow or raw disk.
	// More info: https://kubevirt.gitbooks.io/user-guide/registry-disk.html
	// +optional
	containerDisk?: null | #ContainerDiskSource @go(ContainerDisk,*ContainerDiskSource)

	// Ephemeral is a special volume source that "wraps" specified source and provides copy-on-write image on top of it.
	// +optional
	ephemeral?: null | #EphemeralVolumeSource @go(Ephemeral,*EphemeralVolumeSource)

	// EmptyDisk represents a temporary disk which shares the vmis lifecycle.
	// More info: https://kubevirt.gitbooks.io/user-guide/disks-and-volumes.html
	// +optional
	emptyDisk?: null | #EmptyDiskSource @go(EmptyDisk,*EmptyDiskSource)

	// DataVolume represents the dynamic creation a PVC for this volume as well as
	// the process of populating that PVC with a disk image.
	// +optional
	dataVolume?: null | #DataVolumeSource @go(DataVolume,*DataVolumeSource)

	// ConfigMapSource represents a reference to a ConfigMap in the same namespace.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
	// +optional
	configMap?: null | #ConfigMapVolumeSource @go(ConfigMap,*ConfigMapVolumeSource)

	// SecretVolumeSource represents a reference to a secret data in the same namespace.
	// More info: https://kubernetes.io/docs/concepts/configuration/secret/
	// +optional
	secret?: null | #SecretVolumeSource @go(Secret,*SecretVolumeSource)

	// DownwardAPI represents downward API about the pod that should populate this volume
	// +optional
	downwardAPI?: null | #DownwardAPIVolumeSource @go(DownwardAPI,*DownwardAPIVolumeSource)

	// ServiceAccountVolumeSource represents a reference to a service account.
	// There can only be one volume of this type!
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	serviceAccount?: null | #ServiceAccountVolumeSource @go(ServiceAccount,*ServiceAccountVolumeSource)

	// DownwardMetrics adds a very small disk to VMIs which contains a limited view of host and guest
	// metrics. The disk content is compatible with vhostmd (https://github.com/vhostmd/vhostmd) and vm-dump-metrics.
	downwardMetrics?: null | #DownwardMetricsVolumeSource @go(DownwardMetrics,*DownwardMetricsVolumeSource)

	// MemoryDump is attached to the virt launcher and is populated with a memory dump of the vmi
	memoryDump?: null | #MemoryDumpVolumeSource @go(MemoryDump,*MemoryDumpVolumeSource)
}

// HotplugVolumeSource Represents the source of a volume to mount which are capable
// of being hotplugged on a live running VMI.
// Only one of its members may be specified.
#HotplugVolumeSource: {
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	// Directly attached to the vmi via qemu.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	persistentVolumeClaim?: null | #PersistentVolumeClaimVolumeSource @go(PersistentVolumeClaim,*PersistentVolumeClaimVolumeSource)

	// DataVolume represents the dynamic creation a PVC for this volume as well as
	// the process of populating that PVC with a disk image.
	// +optional
	dataVolume?: null | #DataVolumeSource @go(DataVolume,*DataVolumeSource)
}

#DataVolumeSource: {
	// Name of both the DataVolume and the PVC in the same namespace.
	// After PVC population the DataVolume is garbage collected by default.
	name: string @go(Name)

	// Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
	// +optional
	hotpluggable?: bool @go(Hotpluggable)
}

// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
// Directly attached to the vmi via qemu.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
#PersistentVolumeClaimVolumeSource: {
	v1.#PersistentVolumeClaimVolumeSource

	// Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
	// +optional
	hotpluggable?: bool @go(Hotpluggable)
}

#MemoryDumpVolumeSource: {
	#PersistentVolumeClaimVolumeSource
}

#EphemeralVolumeSource: {
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
	// Directly attached to the vmi via qemu.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	persistentVolumeClaim?: null | v1.#PersistentVolumeClaimVolumeSource @go(PersistentVolumeClaim,*v1.PersistentVolumeClaimVolumeSource)
}

// EmptyDisk represents a temporary disk which shares the vmis lifecycle.
#EmptyDiskSource: {
	// Capacity of the sparse disk.
	capacity: resource.#Quantity @go(Capacity)
}

// Represents a docker image with an embedded disk.
#ContainerDiskSource: {
	// Image is the name of the image with the embedded disk.
	image: string @go(Image)

	// ImagePullSecret is the name of the Docker registry secret required to pull the image. The secret must already exist.
	imagePullSecret?: string @go(ImagePullSecret)

	// Path defines the path to disk file in the container
	path?: string @go(Path)

	// Image pull policy.
	// One of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	imagePullPolicy?: v1.#PullPolicy @go(ImagePullPolicy)
}

// Exactly one of its members must be set.
#ClockOffset: {
	// UTC sets the guest clock to UTC on each boot. If an offset is specified,
	// guest changes to the clock will be kept during reboots and are not reset.
	utc?: null | #ClockOffsetUTC @go(UTC,*ClockOffsetUTC)

	// Timezone sets the guest clock to the specified timezone.
	// Zone name follows the TZ environment variable format (e.g. 'America/New_York').
	timezone?: null | #ClockOffsetTimezone @go(Timezone,*ClockOffsetTimezone)
}

// UTC sets the guest clock to UTC on each boot.
#ClockOffsetUTC: {
	// OffsetSeconds specifies an offset in seconds, relative to UTC. If set,
	// guest changes to the clock will be kept during reboots and not reset.
	offsetSeconds?: null | int @go(OffsetSeconds,*int)
}

// ClockOffsetTimezone sets the guest clock to the specified timezone.
// Zone name follows the TZ environment variable format (e.g. 'America/New_York').
#ClockOffsetTimezone: string

// Represents the clock and timers of a vmi.
// +kubebuilder:pruning:PreserveUnknownFields
#Clock: {
	#ClockOffset

	// Timer specifies whih timers are attached to the vmi.
	// +optional
	timer?: null | #Timer @go(Timer,*Timer)
}

// Represents all available timers in a vmi.
#Timer: {
	// HPET (High Precision Event Timer) - multiple timers with periodic interrupts.
	hpet?: null | #HPETTimer @go(HPET,*HPETTimer)

	// KVM 	(KVM clock) - lets guests read the host’s wall clock time (paravirtualized). For linux guests.
	kvm?: null | #KVMTimer @go(KVM,*KVMTimer)

	// PIT (Programmable Interval Timer) - a timer with periodic interrupts.
	pit?: null | #PITTimer @go(PIT,*PITTimer)

	// RTC (Real Time Clock) - a continuously running timer with periodic interrupts.
	rtc?: null | #RTCTimer @go(RTC,*RTCTimer)

	// Hyperv (Hypervclock) - lets guests read the host’s wall clock time (paravirtualized). For windows guests.
	hyperv?: null | #HypervTimer @go(Hyperv,*HypervTimer)
}

// HPETTickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
#HPETTickPolicy: string // #enumHPETTickPolicy

#enumHPETTickPolicy:
	#HPETTickPolicyDelay |
	#HPETTickPolicyCatchup |
	#HPETTickPolicyMerge |
	#HPETTickPolicyDiscard

// PITTickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
#PITTickPolicy: string // #enumPITTickPolicy

#enumPITTickPolicy:
	#PITTickPolicyDelay |
	#PITTickPolicyCatchup |
	#PITTickPolicyDiscard

// RTCTickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
#RTCTickPolicy: string // #enumRTCTickPolicy

#enumRTCTickPolicy:
	#RTCTickPolicyDelay |
	#RTCTickPolicyCatchup

// HPETTickPolicyDelay delivers ticks at a constant rate. The guest time will
// be delayed due to the late tick
#HPETTickPolicyDelay: #HPETTickPolicy & "delay"

// HPETTickPolicyCatchup Delivers ticks at a higher rate to catch up with the
// missed tick. The guest time should not be delayed once catchup is complete
#HPETTickPolicyCatchup: #HPETTickPolicy & "catchup"

// HPETTickPolicyMerge merges the missed tick(s) into one tick and inject. The
// guest time may be delayed, depending on how the OS reacts to the merging
// of ticks.
#HPETTickPolicyMerge: #HPETTickPolicy & "merge"

// HPETTickPolicyDiscard discards all missed ticks.
#HPETTickPolicyDiscard: #HPETTickPolicy & "discard"

// PITTickPolicyDelay delivers ticks at a constant rate. The guest time will
// be delayed due to the late tick.
#PITTickPolicyDelay: #PITTickPolicy & "delay"

// PITTickPolicyCatchup Delivers ticks at a higher rate to catch up with the
// missed tick. The guest time should not be delayed once catchup is complete.
#PITTickPolicyCatchup: #PITTickPolicy & "catchup"

// PITTickPolicyDiscard discards all missed ticks.
#PITTickPolicyDiscard: #PITTickPolicy & "discard"

// RTCTickPolicyDelay delivers ticks at a constant rate. The guest time will
// be delayed due to the late tick.
#RTCTickPolicyDelay: #RTCTickPolicy & "delay"

// RTCTickPolicyCatchup Delivers ticks at a higher rate to catch up with the
// missed tick. The guest time should not be delayed once catchup is complete.
#RTCTickPolicyCatchup: #RTCTickPolicy & "catchup"

// RTCTimerTrack specifies from which source to track the time.
#RTCTimerTrack: string // #enumRTCTimerTrack

#enumRTCTimerTrack:
	#TrackGuest |
	#TrackWall

// TrackGuest tracks the guest time.
#TrackGuest: #RTCTimerTrack & "guest"

// TrackWall tracks the host time.
#TrackWall: #RTCTimerTrack & "wall"

#RTCTimer: {
	// TickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
	// One of "delay", "catchup".
	tickPolicy?: #RTCTickPolicy @go(TickPolicy)

	// Enabled set to false makes sure that the machine type or a preset can't add the timer.
	// Defaults to true.
	// +optional
	present?: null | bool @go(Enabled,*bool)

	// Track the guest or the wall clock.
	track?: #RTCTimerTrack @go(Track)
}

#HPETTimer: {
	// TickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
	// One of "delay", "catchup", "merge", "discard".
	tickPolicy?: #HPETTickPolicy @go(TickPolicy)

	// Enabled set to false makes sure that the machine type or a preset can't add the timer.
	// Defaults to true.
	// +optional
	present?: null | bool @go(Enabled,*bool)
}

#PITTimer: {
	// TickPolicy determines what happens when QEMU misses a deadline for injecting a tick to the guest.
	// One of "delay", "catchup", "discard".
	tickPolicy?: #PITTickPolicy @go(TickPolicy)

	// Enabled set to false makes sure that the machine type or a preset can't add the timer.
	// Defaults to true.
	// +optional
	present?: null | bool @go(Enabled,*bool)
}

#KVMTimer: {
	// Enabled set to false makes sure that the machine type or a preset can't add the timer.
	// Defaults to true.
	// +optional
	present?: null | bool @go(Enabled,*bool)
}

#HypervTimer: {
	// Enabled set to false makes sure that the machine type or a preset can't add the timer.
	// Defaults to true.
	// +optional
	present?: null | bool @go(Enabled,*bool)
}

#Features: {
	// ACPI enables/disables ACPI inside the guest.
	// Defaults to enabled.
	// +optional
	acpi?: #FeatureState @go(ACPI)

	// Defaults to the machine type setting.
	// +optional
	apic?: null | #FeatureAPIC @go(APIC,*FeatureAPIC)

	// Defaults to the machine type setting.
	// +optional
	hyperv?: null | #FeatureHyperv @go(Hyperv,*FeatureHyperv)

	// SMM enables/disables System Management Mode.
	// TSEG not yet implemented.
	// +optional
	smm?: null | #FeatureState @go(SMM,*FeatureState)

	// Configure how KVM presence is exposed to the guest.
	// +optional
	kvm?: null | #FeatureKVM @go(KVM,*FeatureKVM)

	// Notify the guest that the host supports paravirtual spinlocks.
	// For older kernels this feature should be explicitly disabled.
	// +optional
	pvspinlock?: null | #FeatureState @go(Pvspinlock,*FeatureState)
}

#SyNICTimer: {
	enabled?: null | bool          @go(Enabled,*bool)
	direct?:  null | #FeatureState @go(Direct,*FeatureState)
}

// Represents if a feature is enabled or disabled.
#FeatureState: {
	// Enabled determines if the feature should be enabled or disabled on the guest.
	// Defaults to true.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)
}

#FeatureAPIC: {
	// Enabled determines if the feature should be enabled or disabled on the guest.
	// Defaults to true.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// EndOfInterrupt enables the end of interrupt notification in the guest.
	// Defaults to false.
	// +optional
	endOfInterrupt?: bool @go(EndOfInterrupt)
}

#FeatureSpinlocks: {
	// Enabled determines if the feature should be enabled or disabled on the guest.
	// Defaults to true.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// Retries indicates the number of retries.
	// Must be a value greater or equal 4096.
	// Defaults to 4096.
	// +optional
	spinlocks?: null | uint32 @go(Retries,*uint32)
}

#FeatureVendorID: {
	// Enabled determines if the feature should be enabled or disabled on the guest.
	// Defaults to true.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// VendorID sets the hypervisor vendor id, visible to the vmi.
	// String up to twelve characters.
	vendorid?: string @go(VendorID)
}

// Hyperv specific features.
#FeatureHyperv: {
	// Relaxed instructs the guest OS to disable watchdog timeouts.
	// Defaults to the machine type setting.
	// +optional
	relaxed?: null | #FeatureState @go(Relaxed,*FeatureState)

	// VAPIC improves the paravirtualized handling of interrupts.
	// Defaults to the machine type setting.
	// +optional
	vapic?: null | #FeatureState @go(VAPIC,*FeatureState)

	// Spinlocks allows to configure the spinlock retry attempts.
	// +optional
	spinlocks?: null | #FeatureSpinlocks @go(Spinlocks,*FeatureSpinlocks)

	// VPIndex enables the Virtual Processor Index to help windows identifying virtual processors.
	// Defaults to the machine type setting.
	// +optional
	vpindex?: null | #FeatureState @go(VPIndex,*FeatureState)

	// Runtime improves the time accounting to improve scheduling in the guest.
	// Defaults to the machine type setting.
	// +optional
	runtime?: null | #FeatureState @go(Runtime,*FeatureState)

	// SyNIC enables the Synthetic Interrupt Controller.
	// Defaults to the machine type setting.
	// +optional
	synic?: null | #FeatureState @go(SyNIC,*FeatureState)

	// SyNICTimer enables Synthetic Interrupt Controller Timers, reducing CPU load.
	// Defaults to the machine type setting.
	// +optional
	synictimer?: null | #SyNICTimer @go(SyNICTimer,*SyNICTimer)

	// Reset enables Hyperv reboot/reset for the vmi. Requires synic.
	// Defaults to the machine type setting.
	// +optional
	reset?: null | #FeatureState @go(Reset,*FeatureState)

	// VendorID allows setting the hypervisor vendor id.
	// Defaults to the machine type setting.
	// +optional
	vendorid?: null | #FeatureVendorID @go(VendorID,*FeatureVendorID)

	// Frequencies improves the TSC clock source handling for Hyper-V on KVM.
	// Defaults to the machine type setting.
	// +optional
	frequencies?: null | #FeatureState @go(Frequencies,*FeatureState)

	// Reenlightenment enables the notifications on TSC frequency changes.
	// Defaults to the machine type setting.
	// +optional
	reenlightenment?: null | #FeatureState @go(Reenlightenment,*FeatureState)

	// TLBFlush improves performances in overcommited environments. Requires vpindex.
	// Defaults to the machine type setting.
	// +optional
	tlbflush?: null | #FeatureState @go(TLBFlush,*FeatureState)

	// IPI improves performances in overcommited environments. Requires vpindex.
	// Defaults to the machine type setting.
	// +optional
	ipi?: null | #FeatureState @go(IPI,*FeatureState)

	// EVMCS Speeds up L2 vmexits, but disables other virtualization features. Requires vapic.
	// Defaults to the machine type setting.
	// +optional
	evmcs?: null | #FeatureState @go(EVMCS,*FeatureState)
}

#FeatureKVM: {
	// Hide the KVM hypervisor from standard MSR based discovery.
	// Defaults to false
	hidden?: bool @go(Hidden)
}

// WatchdogAction defines the watchdog action, if a watchdog gets triggered.
#WatchdogAction: string // #enumWatchdogAction

#enumWatchdogAction:
	#WatchdogActionPoweroff |
	#WatchdogActionReset |
	#WatchdogActionShutdown

// WatchdogActionPoweroff will poweroff the vmi if the watchdog gets triggered.
#WatchdogActionPoweroff: #WatchdogAction & "poweroff"

// WatchdogActionReset will reset the vmi if the watchdog gets triggered.
#WatchdogActionReset: #WatchdogAction & "reset"

// WatchdogActionShutdown will shutdown the vmi if the watchdog gets triggered.
#WatchdogActionShutdown: #WatchdogAction & "shutdown"

// Named watchdog device.
#Watchdog: {
	// Name of the watchdog.
	name: string @go(Name)

	#WatchdogDevice
}

// Hardware watchdog device.
// Exactly one of its members must be set.
#WatchdogDevice: {
	// i6300esb watchdog device.
	// +optional
	i6300esb?: null | #I6300ESBWatchdog @go(I6300ESB,*I6300ESBWatchdog)
}

// i6300esb watchdog device.
#I6300ESBWatchdog: {
	// The action to take. Valid values are poweroff, reset, shutdown.
	// Defaults to reset.
	action?: #WatchdogAction @go(Action)
}

#Interface: {
	// Logical name of the interface as well as a reference to the associated networks.
	// Must match the Name of a Network.
	name: string @go(Name)

	// Interface model.
	// One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio.
	// Defaults to virtio.
	// TODO:(ihar) switch to enums once opengen-api supports them. See: https://github.com/kubernetes/kube-openapi/issues/51
	model?: string @go(Model)

	#InterfaceBindingMethod

	// List of ports to be forwarded to the virtual machine.
	ports?: [...#Port] @go(Ports,[]Port)

	// Interface MAC address. For example: de:ad:00:00:be:af or DE-AD-00-00-BE-AF.
	macAddress?: string @go(MacAddress)

	// BootOrder is an integer value > 0, used to determine ordering of boot devices.
	// Lower values take precedence.
	// Each interface or disk that has a boot order must have a unique value.
	// Interfaces without a boot order are not tried.
	// +optional
	bootOrder?: null | uint @go(BootOrder,*uint)

	// If specified, the virtual network interface will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10
	// +optional
	pciAddress?: string @go(PciAddress)

	// If specified the network interface will pass additional DHCP options to the VMI
	// +optional
	dhcpOptions?: null | #DHCPOptions @go(DHCPOptions,*DHCPOptions)

	// If specified, the virtual network interface address and its tag will be provided to the guest via config drive
	// +optional
	tag?: string @go(Tag)

	// If specified, the ACPI index is used to provide network interface device naming, that is stable across changes
	// in PCI addresses assigned to the device.
	// This value is required to be unique across all devices and be between 1 and (16*1024-1).
	// +optional
	acpiIndex?: int @go(ACPIIndex)
}

// Extra DHCP options to use in the interface.
#DHCPOptions: _

// DHCPExtraOptions defines Extra DHCP options for a VM.
#DHCPPrivateOptions: {
	// Option is an Integer value from 224-254
	// Required.
	option: int @go(Option)

	// Value is a String value for the Option provided
	// Required.
	value: string @go(Value)
}

// Represents the method which will be used to connect the interface to the guest.
// Only one of its members may be specified.
#InterfaceBindingMethod: {
	bridge?:     null | #InterfaceBridge     @go(Bridge,*InterfaceBridge)
	slirp?:      null | #InterfaceSlirp      @go(Slirp,*InterfaceSlirp)
	masquerade?: null | #InterfaceMasquerade @go(Masquerade,*InterfaceMasquerade)
	sriov?:      null | #InterfaceSRIOV      @go(SRIOV,*InterfaceSRIOV)
	macvtap?:    null | #InterfaceMacvtap    @go(Macvtap,*InterfaceMacvtap)
	passt?:      null | #InterfacePasst      @go(Passt,*InterfacePasst)
}

// InterfaceBridge connects to a given network via a linux bridge.
#InterfaceBridge: {
}

// InterfaceSlirp connects to a given network using QEMU user networking mode.
#InterfaceSlirp: {
}

// InterfaceMasquerade connects to a given network using netfilter rules to nat the traffic.
#InterfaceMasquerade: {
}

// InterfaceSRIOV connects to a given network by passing-through an SR-IOV PCI device via vfio.
#InterfaceSRIOV: {
}

// InterfaceMacvtap connects to a given network by extending the Kubernetes node's L2 networks via a macvtap interface.
#InterfaceMacvtap: {
}

// InterfacePasst connects to a given network.
#InterfacePasst: {
}

// Port represents a port to expose from the virtual machine.
// Default protocol TCP.
// The port field is mandatory
#Port: {
	// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
	// named port in a pod must have a unique name. Name for the port that can be
	// referred to by services.
	// +optional
	name?: string @go(Name)

	// Protocol for port. Must be UDP or TCP.
	// Defaults to "TCP".
	// +optional
	protocol?: string @go(Protocol)

	// Number of port to expose for the virtual machine.
	// This must be a valid port number, 0 < x < 65536.
	port: int32 @go(Port)
}

#AccessCredentialSecretSource: {
	// SecretName represents the name of the secret in the VMI's namespace
	secretName: string @go(SecretName)
}

#ConfigDriveSSHPublicKeyAccessCredentialPropagation: {
}

// AuthorizedKeysFile represents a path within the guest
// that ssh public keys should be propagated to
#AuthorizedKeysFile: {
	// FilePath represents the place on the guest that the authorized_keys
	// file should be writen to. This is expected to be a full path including
	// both the base directory and file name.
	filePath: string @go(FilePath)
}

#QemuGuestAgentUserPasswordAccessCredentialPropagation: {
}

#QemuGuestAgentSSHPublicKeyAccessCredentialPropagation: {
	// Users represents a list of guest users that should have the ssh public keys
	// added to their authorized_keys file.
	// +listType=set
	users: [...string] @go(Users,[]string)
}

// SSHPublicKeyAccessCredentialSource represents where to retrieve the ssh key
// credentials
// Only one of its members may be specified.
#SSHPublicKeyAccessCredentialSource: {
	// Secret means that the access credential is pulled from a kubernetes secret
	// +optional
	secret?: null | #AccessCredentialSecretSource @go(Secret,*AccessCredentialSecretSource)
}

// SSHPublicKeyAccessCredentialPropagationMethod represents the method used to
// inject a ssh public key into the vm guest.
// Only one of its members may be specified.
#SSHPublicKeyAccessCredentialPropagationMethod: {
	// ConfigDrivePropagation means that the ssh public keys are injected
	// into the VM using metadata using the configDrive cloud-init provider
	// +optional
	configDrive?: null | #ConfigDriveSSHPublicKeyAccessCredentialPropagation @go(ConfigDrive,*ConfigDriveSSHPublicKeyAccessCredentialPropagation)

	// QemuGuestAgentAccessCredentailPropagation means ssh public keys are
	// dynamically injected into the vm at runtime via the qemu guest agent.
	// This feature requires the qemu guest agent to be running within the guest.
	// +optional
	qemuGuestAgent?: null | #QemuGuestAgentSSHPublicKeyAccessCredentialPropagation @go(QemuGuestAgent,*QemuGuestAgentSSHPublicKeyAccessCredentialPropagation)
}

// SSHPublicKeyAccessCredential represents a source and propagation method for
// injecting ssh public keys into a vm guest
#SSHPublicKeyAccessCredential: {
	// Source represents where the public keys are pulled from
	source: #SSHPublicKeyAccessCredentialSource @go(Source)

	// PropagationMethod represents how the public key is injected into the vm guest.
	propagationMethod: #SSHPublicKeyAccessCredentialPropagationMethod @go(PropagationMethod)
}

// UserPasswordAccessCredentialSource represents where to retrieve the user password
// credentials
// Only one of its members may be specified.
#UserPasswordAccessCredentialSource: {
	// Secret means that the access credential is pulled from a kubernetes secret
	// +optional
	secret?: null | #AccessCredentialSecretSource @go(Secret,*AccessCredentialSecretSource)
}

// UserPasswordAccessCredentialPropagationMethod represents the method used to
// inject a user passwords into the vm guest.
// Only one of its members may be specified.
#UserPasswordAccessCredentialPropagationMethod: {
	// QemuGuestAgentAccessCredentailPropagation means passwords are
	// dynamically injected into the vm at runtime via the qemu guest agent.
	// This feature requires the qemu guest agent to be running within the guest.
	// +optional
	qemuGuestAgent?: null | #QemuGuestAgentUserPasswordAccessCredentialPropagation @go(QemuGuestAgent,*QemuGuestAgentUserPasswordAccessCredentialPropagation)
}

// UserPasswordAccessCredential represents a source and propagation method for
// injecting user passwords into a vm guest
// Only one of its members may be specified.
#UserPasswordAccessCredential: {
	// Source represents where the user passwords are pulled from
	source: #UserPasswordAccessCredentialSource @go(Source)

	// propagationMethod represents how the user passwords are injected into the vm guest.
	propagationMethod: #UserPasswordAccessCredentialPropagationMethod @go(PropagationMethod)
}

// AccessCredential represents a credential source that can be used to
// authorize remote access to the vm guest
// Only one of its members may be specified.
#AccessCredential: {
	// SSHPublicKey represents the source and method of applying a ssh public
	// key into a guest virtual machine.
	// +optional
	sshPublicKey?: null | #SSHPublicKeyAccessCredential @go(SSHPublicKey,*SSHPublicKeyAccessCredential)

	// UserPassword represents the source and method for applying a guest user's
	// password
	// +optional
	userPassword?: null | #UserPasswordAccessCredential @go(UserPassword,*UserPasswordAccessCredential)
}

// Network represents a network type and a resource that should be connected to the vm.
#Network: {
	// Network name.
	// Must be a DNS_LABEL and unique within the vm.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	name: string @go(Name)

	#NetworkSource
}

// Represents the source resource that will be connected to the vm.
// Only one of its members may be specified.
#NetworkSource: {
	pod?:    null | #PodNetwork    @go(Pod,*PodNetwork)
	multus?: null | #MultusNetwork @go(Multus,*MultusNetwork)
}

// Represents the stock pod network interface.
#PodNetwork: _

// Rng represents the random device passed from host
#Rng: {
}

// Represents the multus cni network.
#MultusNetwork: {
	// References to a NetworkAttachmentDefinition CRD object. Format:
	// <networkName>, <namespace>/<networkName>. If namespace is not
	// specified, VMI namespace is assumed.
	networkName: string @go(NetworkName)

	// Select the default network and add it to the
	// multus-cni.io/default-network annotation.
	default?: bool @go(Default)
}
